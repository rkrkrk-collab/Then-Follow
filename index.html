<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Then, Follow - 자산배분 백테스트</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script> <!-- Google Identity Services -->
    <!--
    UI Components: Flowbite (MIT License) - https://flowbite.com
    CSS Framework: Tailwind CSS (MIT License) - https://tailwindcss.com
    Font: Inter by Rasmus Andersson (SIL OFL License) - https://rsms.me/inter/
    -->

    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3B82F6',
                            600: '#2563EB',
                            700: '#1D4ED8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        }
                    }
                }
            }
        }
    </script>


    <!-- Flowbite CSS -->
    <link href="https://cdn.jsdelivr.net/npm/flowbite@2.5.1/dist/flowbite.min.css" rel="stylesheet" />

    <style>
        /* ===== CSS 변수 시스템 ===== */
        :root {
            /* 다크모드 (기본) - Bloomberg형 Deep Navy Black */
            /* 배경색 */
            --bg-primary: #0D1117;        /* Background - Bloomberg형 딥 네이비 블랙 */
            --bg-secondary: #161B22;      /* Surface - 배경 대비 약간 밝은 영역 */
            --bg-tertiary: #2D333B;       /* 입력폼, 호버 */
            --bg-dark: #0D1117;           /* 어두운 배경 */
            --bg-darker: #161B22;         /* 더 어두운 배경 */
            --bg-hover: #2D333B;          /* 호버 상태 */
            --bg-overlay: rgba(13, 17, 23, 0.9);  /* 모달 오버레이 */
            --bg-overlay-light: rgba(13, 17, 23, 0.6); /* 연한 오버레이 */

            /* 다크모드 - 테두리 */
            --border-subtle: #2D333B;     /* Border - 은은한 구분선 */
            --border-medium: #2D333B;
            --border-dark: #2D333B;

            /* 다크모드 - 텍스트 */
            --text-primary: #F9FAFB;      /* Text Primary - 거의 흰색, 가독성 우수 */
            --text-secondary: #F9FAFB;    /* Text Secondary - 흰색으로 통일 */
            --text-tertiary: #F9FAFB;     /* 약한 텍스트 - 흰색으로 통일 */
            --text-muted: #F9FAFB;        /* Text Muted - 흰색으로 통일 */
            --text-white: #ffffff;        /* 순수 흰색 */
            --text-black: #000000;        /* 순수 검정 */

            /* 다크모드 - 액센트 색상 */
            --color-primary: #3B82F6;     /* Accent - Bloomberg형 블루 */
            --color-primary-hover: #1D4ED8;  /* Accent Dark - hover, active */
            --color-primary-rgb: 59, 130, 246;
            --color-success: #22C55E;     /* Success - 네온그린 */
            --color-danger: #EF4444;      /* Danger - 라이트레드 */
            --color-warning: #F59E0B;
            --color-info: #3B82F6;
            --color-neutral: #F9FAFB;
            --gradient-primary: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%);

            /* 다크모드 - 반투명 배경 */
            --bg-loading: rgba(13, 17, 23, 0.95);
            --bg-primary-alpha: rgba(59, 130, 246, 0.15);
            --bg-success-alpha: rgba(34, 197, 94, 0.2);
            --bg-warning-alpha: rgba(245, 158, 11, 0.2);
            --bg-danger-alpha: rgba(239, 68, 68, 0.2);
        }

        /* 라이트모드 - Modern Financial Neutral + Blue Accent */
        body.light-mode {
            /* 배경색 */
            --bg-primary: #F8FAFC;         /* Background - 밝은 회백색, 눈부심 방지 */
            --bg-secondary: #FFFFFF;       /* Surface - 주요 컨테이너 배경 */
            --bg-tertiary: #F1F5F9;        /* 입력폼 배경 */
            --bg-dark: #F8FAFC;            /* 라이트모드에선 Background */
            --bg-darker: #FFFFFF;          /* 라이트모드 어두운 배경 */
            --bg-hover: #F1F5F9;           /* 호버 상태 */
            --bg-overlay: rgba(17, 24, 39, 0.6);  /* 모달 오버레이 */
            --bg-overlay-light: rgba(17, 24, 39, 0.3); /* 연한 오버레이 */

            /* 테두리 */
            --border-subtle: #E5E7EB;      /* Border - 구분선, 그리드라인 */
            --border-medium: #E5E7EB;
            --border-dark: #E5E7EB;

            /* 텍스트 */
            --text-primary: #111827;       /* Text Primary - 메인 글자색 */
            --text-secondary: #111827;     /* Text Secondary - 검정으로 통일 */
            --text-tertiary: #111827;      /* 약한 텍스트 - 검정으로 통일 */
            --text-muted: #111827;         /* Text Muted - 검정으로 통일 */
            --text-white: #ffffff;         /* 순수 흰색 (버튼 등) */
            --text-black: #000000;         /* 순수 검정 */

            /* 액센트 색상 */
            --color-primary: #2563EB;      /* Accent - 인터랙션/링크 강조색 */
            --color-primary-hover: #1D4ED8;  /* hover 상태 */
            --color-primary-rgb: 37, 99, 235;
            --color-success: #16A34A;      /* Success - 상승/성공 구간 */
            --color-danger: #DC2626;       /* Danger - 하락/위험 구간 */
            --color-warning: #F59E0B;
            --color-info: #2563EB;
            --color-neutral: #111827;
            --gradient-primary: linear-gradient(135deg, #2563EB 0%, #1D4ED8 100%);

            /* 반투명 배경 */
            --bg-loading: rgba(248, 250, 252, 0.98);
            --bg-primary-alpha: #DBEAFE;   /* Accent Light - hover, 선택 영역 */
            --bg-success-alpha: rgba(22, 163, 74, 0.1);
            --bg-warning-alpha: rgba(245, 158, 11, 0.1);
            --bg-danger-alpha: rgba(220, 38, 38, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Inter', 'Pretendard', -apple-system, BlinkMacSystemFont, 'Malgun Gothic', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;  /* 1.4 → 1.6 */
            font-size: 16px;   /* 18px → 16px */
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
        }

        /* 모든 제목 요소에 명시적으로 텍스트 색상 지정 */
        h1, h2, h3, h4, h5, h6 {
            color: var(--text-primary);
        }
        
        /* 로딩 및 피드백 스타일 */
        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-dark);
            border-top: 3px solid var(--color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        .loading-spinner.small {
            width: 20px;
            height: 20px;
            border-width: 2px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-hover);
            border-radius: 4px;
            overflow: hidden;
            margin: 16px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient-primary);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        /* 로딩 오버레이 */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-loading);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 16px;
            z-index: 100;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-content {
            text-align: center;
            max-width: 200px;
        }

        .loading-title {
            font-size: 16px;
            font-weight: 600;
            margin: 16px 0 8px 0;
            color: var(--text-primary);
        }

        .loading-subtitle {
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1.4;
        }
        
        /* 성공/오류 알림 */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-success);
            color: var(--text-white);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notification.show {
            opacity: 1;
        }

        .notification.error {
            background: var(--color-danger);
        }

        .notification.warning {
            background: var(--color-warning);
        }

        .notification.info {
            background: var(--color-info);
        }

        /* 햄버거 메뉴 */
        .menu-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background: var(--bg-darker);
            border: 1px solid var(--border-dark);
            border-radius: 8px;
            width: 44px;
            height: 44px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            transition: all 0.3s ease;
        }

        .menu-button:hover {
            background: var(--bg-hover);
        }

        .menu-line {
            width: 18px;
            height: 2px;
            background: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .menu-button.active .menu-line:nth-child(1) {
            transform: rotate(45deg) translate(6px, 6px);
        }
        
        .menu-button.active .menu-line:nth-child(2) {
            opacity: 0;
        }
        
        .menu-button.active .menu-line:nth-child(3) {
            transform: rotate(-45deg) translate(6px, -6px);
        }
        
        /* 사이드 메뉴 */
        .side-menu {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100vh;
            background: var(--bg-dark);
            z-index: 1000;
            transition: right 0.3s ease;
            border-left: 1px solid var(--border-dark);
            padding: 80px 0 20px 0;
            overflow-y: auto;
        }

        .side-menu.active {
            right: 0;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-overlay-light);
            z-index: 999;
            display: none;
        }

        .menu-overlay.active {
            display: block;
        }

        .menu-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-dark);
        }

        .menu-section:last-child {
            border-bottom: none;
        }

        .menu-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            cursor: pointer;
            transition: color 0.2s;
        }

        .menu-item:hover {
            color: var(--color-primary);
        }

        .menu-item-label {
            font-size: 16px;
        }

        .menu-item-value {
            font-size: 14px;
            color: var(--text-muted);
        }

        /* 토글 스위치 */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--bg-hover);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--color-primary);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: var(--text-white);
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }
        
        /* 라이트 모드 */
        .light-mode .logo {
            background: var(--gradient-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .light-mode .notification {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .light-mode .positive {
            color: var(--color-success);
        }

        .light-mode .negative {
            color: var(--color-danger);
        }

        /* 라이트모드는 CSS 변수로 자동 처리되므로 대부분의 오버라이드 불필요 */
        /* 체크박스 accent color만 명시 */
        .light-mode .strategy-checkbox {
            accent-color: var(--color-primary);
        }
        
        /* 랭킹 아이템 스타일 */
        .ranking-item {
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .ranking-item:hover {
            background: var(--bg-hover) !important;
        }

        body:not(.light-mode) .ranking-item:hover {
            background: var(--bg-hover) !important;
        }

        .light-mode .ranking-item:hover {
            background: var(--bg-hover) !important;
        }

        .ranking-item input[type="checkbox"]:checked + .strategy-details {
            opacity: 0.9;
        }

        @media (max-width: 768px) {
            .ranking-item {
                margin-bottom: 6px;
            }
            
            .ranking-item .name {
                font-size: 14px !important;
            }
            
            .ranking-item .creator {
                font-size: 11px !important;
            }
        }
        
        /* 1단계: 홈 화면 (구글 스타일) */
        .home-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 28px;  /* 20px → 28px 패딩 증가 */
        }

        .logo {
            font-size: 52px;  /* 48px → 52px 로고 크기 증가 */
            font-weight: 800;
            margin-bottom: 48px;  /* 40px → 48px 여백 증가 */
            background: var(--gradient-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            letter-spacing: -1px;  /* 로고 간격 조정 */
        }

        .search-container {
            width: 100%;
            max-width: 520px;  /* 500px → 520px 너비 증가 */
            position: relative;
            margin-bottom: 48px;  /* 40px → 48px 여백 증가 */
        }
        
        .search-box {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 14px;
            width: 100%;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--color-primary);
            background: var(--bg-tertiary);
        }

        .search-box::placeholder {
            color: var(--text-tertiary);
        }
        
        /* 전략 선택 모달 */
        .strategy-selector-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-overlay);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .strategy-selector-modal.active {
            display: flex;
        }

        .strategy-selector-content {
            background: var(--bg-darker);
            border-radius: 16px;
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-dark);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
        }
        
        .search-filter {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-dark);
        }

        .search-filter input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
        }

        .strategy-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px 0;
        }

        .strategy-item {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .strategy-item:hover {
            background: var(--bg-hover);
        }

        /* 다크모드 명시적 설정 */
        body:not(.light-mode) .strategy-item:hover {
            background: var(--bg-hover) !important;
        }

        /* 라이트모드 설정 */
        .light-mode .strategy-item:hover {
            background: var(--bg-hover) !important;
        }

        .strategy-checkbox {
            margin-right: 16px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background: var(--bg-secondary);
            border: 2px solid var(--border-medium);
            border-radius: 4px;
            position: relative;
            transition: all 0.2s ease;
        }

        /* 체크박스 체크된 상태 (다크 모드) */
        .strategy-checkbox:checked {
            background: var(--color-primary);
            border-color: var(--color-primary);
        }

        /* 체크 표시 (✓) - 다크 모드 */
        .strategy-checkbox:checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 16px;
            font-weight: bold;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* 체크박스 호버 효과 */
        .strategy-checkbox:hover {
            border-color: var(--color-primary);
        }
        
        .strategy-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .strategy-details .name {
            font-weight: 600;
        }

        /* 전략 성과 프리뷰 스타일 */
        .strategy-preview {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        .risk-badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .risk-badge.risk-low {
            background: var(--bg-success-alpha);
            color: var(--color-success);
        }

        .risk-badge.risk-medium {
            background: var(--bg-primary-alpha);
            color: var(--color-primary);
        }

        .risk-badge.risk-high {
            background: var(--bg-warning-alpha);
            color: var(--color-warning);
        }

        .preview-metric {
            display: flex;
            gap: 4px;
            align-items: center;
            font-size: 11px;
        }

        .preview-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .preview-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .preview-value.positive {
            color: var(--color-success);
        }

        .preview-value.negative {
            color: var(--color-danger);
        }

        /* 지표 설명 아이콘 */
        .help-icon-inline {
            display: inline-block;
            width: 14px;
            height: 14px;
            line-height: 14px;
            text-align: center;
            background: var(--bg-primary-alpha);
            color: var(--color-primary);
            border-radius: 50%;
            font-size: 10px;
            font-weight: 700;
            margin-left: 4px;
            cursor: help;
        }

        /* 지표 설명 모달 */
        .metric-explanation-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-overlay);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .metric-explanation-content {
            background: var(--bg-secondary);
            border-radius: 16px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .metric-explanation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .metric-explanation-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 20px;
        }

        .metric-explanation-body {
            padding: 20px;
        }

        .metric-current-value {
            padding: 12px 16px;
            background: var(--bg-primary-alpha);
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metric-current-value .label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .metric-current-value .value {
            color: var(--color-primary);
            font-size: 24px;
            font-weight: 700;
        }

        .metric-description,
        .metric-interpretation,
        .metric-formula {
            margin-bottom: 16px;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .metric-formula code {
            display: block;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
            margin-top: 8px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
        }

        /* ETF 정보 모달 스타일 */
        .etf-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-overlay);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .etf-info-content {
            background: var(--bg-secondary);
            border-radius: 16px;
            max-width: 450px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .etf-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .etf-info-header h3 {
            margin: 0;
            color: var(--color-primary);
            font-size: 22px;
            font-weight: 700;
        }

        .etf-info-body {
            padding: 20px;
        }

        .etf-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .etf-info-row:last-of-type {
            border-bottom: none;
        }

        .etf-info-row .label {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        .etf-info-row .value {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
            text-align: right;
        }

        .etf-info-description {
            margin-top: 16px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 13px;
        }

        .etf-info-description strong {
            color: var(--color-primary);
        }

        /* 튜토리얼 스타일 */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-overlay);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 20px;
        }

        .tutorial-overlay.active {
            display: flex;
        }

        .tutorial-content {
            background: var(--bg-secondary);
            border-radius: 20px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 24px 28px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .tutorial-header h3 {
            margin: 0;
            color: var(--color-primary);
            font-size: 22px;
            font-weight: 700;
        }

        .tutorial-body {
            padding: 32px 28px;
            min-height: 300px;
        }

        .tutorial-step {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .tutorial-step.hidden {
            display: none;
        }

        .tutorial-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 16px;
        }

        .tutorial-step h4 {
            color: var(--text-primary);
            font-size: 20px;
            font-weight: 700;
            margin: 0 0 16px 0;
            text-align: center;
        }

        .tutorial-step p {
            color: var(--text-primary);
            font-size: 15px;
            line-height: 1.7;
            margin-bottom: 12px;
        }

        .tutorial-tip {
            background: var(--bg-primary-alpha);
            border-left: 3px solid var(--color-primary);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px !important;
            margin-top: 16px !important;
        }

        .tutorial-tips-list {
            color: var(--text-primary);
            font-size: 15px;
            line-height: 1.8;
            padding-left: 24px;
        }

        .tutorial-tips-list li {
            margin-bottom: 10px;
        }

        .tutorial-footer {
            padding: 20px 28px;
            border-top: 1px solid var(--border-subtle);
        }

        .tutorial-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .progress-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--border-subtle);
            transition: all 0.3s ease;
        }

        .progress-dot.active {
            background: var(--color-primary);
            width: 24px;
            border-radius: 5px;
        }

        .tutorial-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
        }

        .tutorial-checkbox input {
            cursor: pointer;
        }

        .tutorial-btn {
            padding: 10px 20px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 8px;
        }

        .tutorial-btn:hover {
            background: var(--color-primary-hover);
            transform: translateY(-1px);
        }

        .tutorial-prev {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .tutorial-prev:hover {
            background: var(--border-subtle);
        }

        .tutorial-btn.hidden {
            display: none;
        }

        .strategy-details .creator {
            font-size: 12px;
            color: var(--text-muted);
        }

        .selector-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-top: 1px solid var(--border-dark);
        }

        .selected-count {
            color: var(--text-muted);
        }

        .confirm-btn {
            background: var(--color-primary);
            border: none;
            color: var(--text-white);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        /* 성과별 최고 전략 찾기 */
        .performance-buttons {
            width: 100%;
            max-width: 500px;
            margin-bottom: 32px;
        }

        .section-title {
            font-size: 16px;  /* 20px → 16px */
            font-weight: 600;
            margin-bottom: 12px;
            text-align: center;
            color: var(--text-primary);
        }
        
        .performance-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .performance-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-primary);
        }

        .performance-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--color-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }

        .performance-btn:active {
            transform: translateY(0);
        }

        .btn-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .btn-text {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
        }

        /* 2단계: 선택 화면 */
        .selection-screen {
            display: none;
            padding: 28px;  /* 20px → 28px 패딩 증가 */
            min-height: 100vh;
        }

        .header {
            display: flex;
            align-items: center;
            margin-bottom: 36px;  /* 30px → 36px 여백 증가 */
            padding-top: max(24px, env(safe-area-inset-top));  /* 20px → 24px */
        }

        .back-btn {
            background: none;
            border: none;
            color: var(--color-primary);
            font-size: 24px;
            margin-right: 16px;
            cursor: pointer;
        }
        
        .header-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .selected-strategies {
            margin-bottom: 30px;
        }
        
        .selected-strategy-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 12px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .selected-strategy-card:hover {
            border-color: var(--border-medium);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .remove-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: var(--color-danger);
            border: none;
            color: var(--text-white);
            width: 24px;
            height: 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
        }

        .strategy-info h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .strategy-info .creator {
            color: var(--text-muted);
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .strategy-info .description {
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .add-more-btn {
            width: 100%;
            padding: 16px;
            background: transparent;
            border: 2px dashed var(--border-dark);
            border-radius: 16px;
            color: var(--text-muted);
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 30px;
        }

        .add-more-btn:hover {
            border-color: var(--color-primary);
            color: var(--color-primary);
        }

        .compare-btn {
            width: 100%;
            padding: 16px;
            background: var(--color-primary);
            border: none;
            border-radius: 12px;
            color: var(--text-white);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .compare-btn:disabled {
            background: var(--bg-hover);
            cursor: not-allowed;
        }
        
        /* 3단계: 분석 화면 */
        .analysis-screen {
            display: none;
            padding: 28px;  /* 20px → 28px 패딩 증가 */
            padding-bottom: 48px;  /* 40px → 48px 하단 여백 증가 */
        }

        .section {
            margin-bottom: 32px;  /* 24px → 32px 섹션 간격 증가 */
        }

        .settings-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 24px;  /* 20px → 24px 패딩 증가 */
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label,
        .metric-label,
        .creator,
        .assumption-label {
            color: var(--text-secondary);
        }

        /* 비활성 상태 */
        .disabled {
            color: var(--text-tertiary);
        }

        /* 진행률 텍스트 */
        .progress-text {
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            margin-top: 8px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .form-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .form-input:focus {
            border-color: var(--color-primary);
            background: var(--bg-tertiary);
            outline: none;
        }

        .form-input::placeholder {
            color: var(--text-tertiary);
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .run-btn,
        .compare-btn,
        .confirm-btn {
            background: var(--gradient-primary);
            border: none;
            color: white;
            padding: 16px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .run-btn:hover,
        .compare-btn:hover,
        .confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }

        .run-btn:active,
        .compare-btn:active,
        .confirm-btn:active {
            transform: translateY(0);
        }

        /* 빠른 날짜 선택 버튼 */
        .quick-date-btn {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-medium);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-date-btn:hover {
            background: var(--color-primary);
            border-color: var(--color-primary);
            color: white;
            transform: translateY(-1px);
        }

        .quick-date-btn:active {
            transform: translateY(0);
        }

        .light-mode .quick-date-btn {
            background: var(--bg-darker);
            border-color: var(--border-dark);
            color: var(--text-primary);
        }

        .light-mode .quick-date-btn:hover {
            background: var(--color-primary);
            border-color: var(--color-primary);
            color: white;
        }

        .results-card {
            background: var(--bg-darker);
            border-radius: 16px;
            padding: 20px;
            display: none;
            position: relative;
        }

        .chart-container {
            height: 450px;  /* 누적수익률 차트 가독성 향상을 위해 높이 증가 */
            margin: 28px 0;  /* 24px → 28px 여백 추가 증가 */
            position: relative;
            padding: 16px;  /* 차트 내부 여백 추가 */
            background: var(--bg-dark);
            border-radius: 12px;
        }

        /* 차트 컨트롤 */
        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 14px 18px;  /* 12px 16px → 14px 18px 패딩 증가 */
            background: var(--bg-dark);
            border-radius: 8px;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .period-selector {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .control-label {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .period-buttons {
            display: flex;
            gap: 4px;
            background: var(--bg-darker);
            border-radius: 6px;
            padding: 2px;
        }

        .period-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .period-btn:hover {
            color: var(--color-primary);
            background: var(--bg-primary-alpha);
        }

        .period-btn.active {
            background: var(--color-primary);
            color: var(--text-white);
        }

        .chart-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: var(--bg-darker);
            border: 1px solid var(--border-dark);
            color: var(--text-muted);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .action-btn:hover {
            background: var(--bg-hover);
            color: var(--color-primary);
            border-color: var(--color-primary);
        }
        
        .action-btn .btn-icon {
            font-size: 14px;
        }
        
        .action-btn .btn-text {
            font-weight: 500;
        }
        
        /* 차트 인터랙션 개선 */
        .chart-interactive {
            cursor: crosshair;
            user-select: none;
        }
        
        .chart-interactive:active {
            cursor: grabbing;
        }
        
        /* 차트 정보 오버레이 */
        .chart-info-overlay {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(42, 42, 42, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-dark);
            border-radius: 8px;
            padding: 12px;
            min-width: 200px;
            color: var(--text-white);
            font-size: 12px;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 10;
        }

        .chart-info-overlay.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .chart-info-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--color-primary);
            border-bottom: 1px solid var(--border-dark);
            padding-bottom: 4px;
        }

        .chart-info-item {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            padding: 2px 0;
        }

        .chart-info-label {
            color: var(--text-muted);
        }

        .chart-info-value {
            font-weight: 600;
            color: var(--text-white);
        }

        .chart-info-value.positive {
            color: var(--color-success);
        }

        .chart-info-value.negative {
            color: var(--color-danger);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 20px;
        }
        
        .metric-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 20px 22px;  /* 18px → 20px 22px 패딩 추가 증가 */
            transition: all 0.2s ease;
            min-height: 120px;  /* 최소 높이 지정으로 일관성 확보 */
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .metric-item:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-medium);
            transform: translateY(-3px);  /* -2px → -3px 호버 효과 강화 */
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);  /* 그림자 강화 */
        }

        .metric-label {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;  /* 여백 추가 */
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        .metric-value {
            font-size: 26px;  /* 22px → 26px 크기 추가 증가 */
            font-weight: 700;
            margin-bottom: 8px;  /* 6px → 8px 여백 증가 */
            line-height: 1.2;
            letter-spacing: -0.5px;  /* 숫자 간격 조정 */
        }

        /* 지표 설명 툴팁 */
        .metric-help {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .help-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--color-primary);
            color: var(--text-white);
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .help-icon:hover {
            background: var(--color-primary-hover);
            transform: scale(1.1);
        }

        .metric-tooltip {
            position: fixed;
            background: var(--bg-darker);
            color: var(--text-white);
            padding: 16px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .metric-tooltip.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .tooltip-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--color-primary);
        }

        .tooltip-description {
            font-size: 12px;
            line-height: 1.6;  /* 1.4 → 1.6 개선 */
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .tooltip-formula {
            font-size: 11px;
            font-family: monospace;
            background: var(--bg-dark);
            padding: 6px 8px;
            border-radius: 4px;
            margin: 6px 0;
            color: var(--text-muted);
            white-space: pre-wrap;
        }

        .tooltip-interpretation {
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
            white-space: pre-wrap;
            margin-top: 8px;
        }
        
        /* 포트폴리오 구성 탭 스타일 */
        .rebalancing-settings {
            background: var(--bg-dark);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
        }

        .rebalancing-settings h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .portfolio-charts {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .chart-section {
            background: var(--bg-dark);
            border-radius: 12px;
            padding: 24px;  /* 20px → 24px 패딩 증가 */
        }

        .chart-section h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 18px;  /* 16px → 18px 여백 증가 */
            color: var(--text-primary);
        }

        .pie-charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .pie-chart-wrapper {
            position: relative;
            background: var(--bg-darker);
            border-radius: 12px;
            padding: 20px;
        }

        .pie-chart-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            text-align: center;
            color: var(--text-primary);
        }

        .pie-chart-container {
            height: 350px;
            position: relative;
        }

        .allocation-chart-container {
            height: 300px;
            margin: 20px 0;
        }

        .rebalancing-analysis {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }

        .rebalancing-metric {
            background: var(--bg-darker);
            border-radius: 8px;
            padding: 18px;  /* 16px → 18px 패딩 증가 */
            text-align: center;
        }

        .rebalancing-metric .metric-title {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .rebalancing-metric .metric-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .allocation-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        /* 상세 분석 테이블 */
        .analysis-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-dark);
        }

        .tab-button {
            background: none;
            border: none;
            color: var(--text-muted);
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-button.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-dark);
            border-radius: 8px;
            overflow: hidden;
        }

        .metrics-table th,
        .metrics-table td {
            padding: 16px 18px;  /* 14px 16px → 16px 18px 패딩 추가 증가 */
            text-align: left;
            border-bottom: 1px solid var(--border-dark);
            line-height: 1.6;  /* 가독성을 위한 행 높이 */
        }

        .metrics-table th {
            background: var(--bg-darker);
            font-weight: 700;  /* 600 → 700 헤더 강조 */
            color: var(--text-primary);
            font-size: 15px;  /* 14px → 15px 헤더 크기 증가 */
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metrics-table td {
            font-size: 14px;
            color: var(--text-primary);
        }

        /* 숫자 열 오른쪽 정렬 */
        .metrics-table td:not(:first-child) {
            text-align: right;
        }

        /* Zebra striping - 행 구분 강화 */
        .metrics-table tbody tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        .metrics-table tr:last-child td {
            border-bottom: none;
        }

        .metrics-table tr:hover td {
            background: var(--bg-hover);
            transform: scale(1.01);
            transition: all 0.2s ease;
        }

        .positive { color: var(--color-success); }
        .negative { color: var(--color-danger); }
        .neutral { color: var(--color-neutral); }
        
        /* 연도별 성과 테이블 */
        .yearly-performance {
            overflow-x: auto;
        }

        .yearly-table {
            width: 100%;
            min-width: 600px;
            border-collapse: collapse;
            background: var(--bg-dark);
            border-radius: 8px;
            overflow: hidden;
        }

        .yearly-table th,
        .yearly-table td {
            padding: 14px 16px;  /* 12px → 14px 16px 패딩 증가 */
            text-align: center;
            border: 1px solid var(--border-dark);
            font-size: 14px;  /* 13px → 14px 크기 증가 */
            line-height: 1.6;
        }

        .yearly-table th {
            background: var(--bg-darker);
            font-weight: 700;  /* 600 → 700 헤더 강조 */
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .yearly-table td {
            color: var(--text-primary);
        }

        .yearly-table .strategy-name {
            text-align: left;
            font-weight: 600;
        }

        /* Zebra striping */
        .yearly-table tbody tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        .yearly-table tr:hover td {
            background: var(--bg-hover);
            transition: all 0.2s ease;
        }

        /* 상관관계 매트릭스 */
        .correlation-matrix {
            display: grid;
            gap: 2px;
            margin: 20px 0;
            background: var(--border-dark);
            border-radius: 8px;
            padding: 2px;
        }

        .correlation-cell {
            background: var(--bg-dark);
            padding: 10px;  /* 8px → 10px 패딩 증가 */
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            border-radius: 4px;
            min-height: 44px;  /* 40px → 44px 최소 높이 증가 */
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
        }

        .correlation-header {
            background: var(--bg-darker);
            font-weight: 600;
            color: var(--text-primary);
        }
        
        /* 벤치마크 비교 차트 */
        .benchmark-section {
            margin-top: 30px;
        }
        
        .benchmark-chart-container {
            height: 300px;
            margin: 20px 0;
        }
        
        /* 라이트 모드 */
        .light-mode .chart-controls {
            background: var(--bg-darker);
        }

        .light-mode .period-buttons {
            background: var(--bg-hover);
        }

        .light-mode .period-btn {
            color: var(--text-muted);
        }

        .light-mode .period-btn:hover {
            background: var(--bg-primary-alpha);
            color: var(--color-primary);
        }

        .light-mode .action-btn {
            background: var(--bg-hover);
            border-color: var(--border-dark);
            color: var(--text-muted);
        }

        .light-mode .action-btn:hover {
            background: var(--bg-tertiary);
            color: var(--color-primary);
            border-color: var(--color-primary);
        }

        /* 라이트 모드 - 차트 스타일 */
        .light-mode canvas {
            background: transparent !important;
        }
        
        .text-red { color: var(--color-danger); }
        .text-blue { color: var(--color-info); }
        .text-green { color: var(--color-success); }
        
        /* 모바일 최적화 */
        @media (max-width: 768px) {
            .analysis-tabs {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 8px;
                margin-bottom: 16px;
                gap: 8px;
            }
            
            .tab-button {
                white-space: nowrap;
                min-width: 80px;
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .chart-container {
                height: 280px;  /* 모바일에서도 누적수익률 차트 가독성 향상 */
                margin: 12px 0;
            }
            
            .benchmark-chart-container,
            .allocation-chart-container {
                height: 220px;
                margin: 12px 0;
            }
            
            .pie-chart-container {
                height: 180px;
            }
            
            .pie-charts-container {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .metric-item {
                padding: 12px;
            }
            
            .metric-value {
                font-size: 18px;
            }
            
            .metric-label {
                font-size: 11px;
            }
        }
        
        /* 애니메이션 */
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        input[type="date"] {
            cursor: pointer;
            position: relative;
        }

        /* 다크모드 기본 설정 (body에 light-mode 클래스가 없을 때) */
        body:not(.light-mode) input[type="date"]::-webkit-calendar-picker-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: auto;
            height: auto;
            color: transparent;
            background: transparent;
            cursor: pointer;
            filter: invert(1) !important; /* 다크모드에서 흰색으로 강제 변경 */
        }

        /* 라이트 모드에서 달력 아이콘 색상 */
        .light-mode input[type="date"]::-webkit-calendar-picker-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: auto;
            height: auto;
            color: transparent;
            background: transparent;
            cursor: pointer;
            filter: invert(0) !important; /* 라이트모드에서 검정색으로 강제 변경 */
        }

        .form-input[type="date"] {
            padding-right: 10px;
        }

        /* 월 입력 필드 전체 클릭 가능하게 */
        .form-input[type="month"] {
            cursor: pointer;
            position: relative;
        }

        .form-input[type="month"]::-webkit-calendar-picker-indicator {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            opacity: 0;
            cursor: pointer;
        }

        /* 관리자 로그인 모달 */
        .admin-login-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .admin-login-modal.active {
            display: flex;
        }

        .admin-login-content {
            background: var(--bg-darker);
            border-radius: 16px;
            padding: 30px;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }

        .admin-login-content h3 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .admin-login-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .admin-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .admin-btn.cancel {
            background: var(--text-secondary);
            color: var(--text-white);
        }

        .admin-btn.confirm {
            background: var(--color-primary);
            color: var(--text-white);
        }

        .admin-btn.danger {
            background: var(--color-danger);
            color: var(--text-white);
        }

        .admin-btn.secondary {
            background: var(--text-secondary);
            color: var(--text-white);
        }

        /* 데이터 관리 모달 */
        .data-management-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .data-management-modal.active {
            display: flex;
        }

        .data-management-content {
            background: var(--bg-darker);
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .data-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-dark);
        }

        .data-management-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-dark);
        }

        .upload-area {
            border: 2px dashed var(--border-medium);
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: var(--color-primary);
            background: var(--bg-primary-alpha);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .upload-text {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .upload-subtext {
            font-size: 14px;
            color: var(--text-muted);
        }

        .data-status {
            background: var(--bg-dark);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .status-label {
            font-size: 14px;
            color: var(--text-muted);
        }

        .status-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .data-actions {
            display: flex;
            gap: 12px;
        }

        /* 라이트 모드 스타일 */
        .light-mode .admin-login-content,
        .light-mode .data-management-content {
            background: var(--bg-dark);
            color: var(--text-primary);
        }

        .light-mode .admin-login-content h3,
        .light-mode .data-management-header h3 {
            color: var(--text-primary);
        }

        .light-mode .data-management-header,
        .light-mode .data-management-section {
            border-color: var(--border-dark);
        }

        .light-mode .data-status {
            background: var(--bg-darker);
        }

        .light-mode .status-value {
            color: var(--text-primary);
        }

        .light-mode .upload-text {
            color: var(--text-primary);
        }

        .light-mode .upload-area {
            border-color: var(--border-dark);
        }

        /* 구글 로그인 스타일 */
        .google-login-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-dark);
        }

        .google-signin-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            width: 100%;
            padding: 12px 20px;
            background: var(--text-white);
            color: #3c4043;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .google-signin-btn:hover {
            background: #f8f9fa;
            border-color: #d2e3fc;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,.3), 0 1px 3px 1px rgba(60,64,67,.15);
        }

        .google-signin-btn:disabled {
            background: #f1f3f4;
            color: #80868b;
            cursor: not-allowed;
            border-color: #dadce0;
        }

        .google-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid var(--color-primary);
        }

        .user-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .user-email {
            font-size: 12px;
            color: var(--text-muted);
        }

        .logout-btn {
            padding: 6px 12px;
            background: var(--text-secondary);
            color: var(--text-white);
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .logout-btn:hover {
            background: var(--text-tertiary);
        }

        .login-prompt {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .login-benefits {
            list-style: none;
            margin: 12px 0 0 0;
            padding: 0;
            font-size: 12px;
            line-height: 1.4;
        }

        .login-benefits li {
            margin-bottom: 4px;
            color: var(--text-muted);
        }

        .login-benefits li:before {
            content: "✓ ";
            color: var(--color-success);
            font-weight: bold;
        }

        .login-status {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 999;
            background: rgba(42, 42, 42, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-dark);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            color: var(--text-white);
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .login-status.show {
            opacity: 1;
            transform: translateY(0);
        }

        .login-status.success {
            border-color: var(--color-success);
            color: var(--color-success);
        }

        .login-status.error {
            border-color: var(--color-danger);
            color: var(--color-danger);
        }

        .light-mode .google-login-section {
            border-color: var(--border-dark);
        }

        .light-mode .user-name {
            color: var(--text-primary);
        }

        .light-mode .login-prompt {
            color: var(--text-muted);
        }

        .light-mode .login-benefits li {
            color: var(--text-muted);
        }

        .light-mode .login-status {
            background: rgba(255, 255, 255, 0.95);
            border-color: var(--border-dark);
            color: var(--text-primary);
        }

        /* 면책 조항 */
        .disclaimer {
            max-width: 600px;
            margin: 40px auto 20px;
            padding: 24px;  /* 20px → 24px 패딩 증가 */
            background: rgba(142, 142, 147, 0.1);
            border: 1px solid rgba(142, 142, 147, 0.2);
            border-radius: 12px;
            text-align: center;
        }

        .disclaimer-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .disclaimer-text {
            font-size: 13px;
            line-height: 1.7;  /* 1.6 → 1.7 개선 */
            color: var(--text-secondary);
            margin: 0;
        }

        .light-mode .disclaimer {
            background: rgba(0, 0, 0, 0.03);
        }

        .light-mode .disclaimer-title {
            color: var(--text-secondary);
        }

        .light-mode .disclaimer-text {
            color: var(--text-secondary);
        }

        /* 백테스트 가정 스타일 */
        .backtest-assumptions {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;  /* 6px → 8px 간격 증가 */
        }

        .assumption-item {
            text-align: center;
            padding: 12px 8px;  /* 8px 6px → 12px 8px 패딩 증가 */
            background: var(--bg-dark);
            border-radius: 6px;
        }

        .assumption-value {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        /* 라이트 모드 */
        .light-mode .assumption-item {
            background: var(--bg-darker);
        }

        .light-mode .assumption-value {
            color: var(--text-primary);
        }

        /* 모바일 */
        @media (max-width: 768px) {
            .backtest-assumptions {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* 라이트 모드 - 상세 지표 테이블 */
        .light-mode .metrics-table {
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
        }

        .light-mode .metrics-table th {
            background: var(--bg-darker);
            color: var(--text-primary);
            border-bottom: 2px solid var(--border-dark);
        }

        .light-mode .metrics-table td {
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-subtle);
        }

        .light-mode .metrics-table tr:hover {
            background: var(--bg-hover);
        }

        /* 라이트 모드 - 연도별 성과 테이블 */
        .light-mode .yearly-table {
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
        }

        .light-mode .yearly-table th {
            background: var(--bg-darker);
            color: var(--text-primary);
            border: 1px solid var(--border-dark);
        }

        .light-mode .yearly-table td {
            color: var(--text-primary);
            border: 1px solid var(--border-subtle);
        }

        .light-mode .yearly-table .strategy-name {
            background: var(--bg-hover);
            font-weight: 600;
        }

        /* 라이트 모드 - 벤치마크 테이블 */
        .light-mode #benchmark-table {
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
        }

        .light-mode #benchmark-table th {
            background: var(--bg-darker);
            color: var(--text-primary);
        }

        .light-mode #benchmark-table td {
            color: var(--text-primary);
        }

        /* 라이트 모드 - 상관관계 매트릭스 */
        .light-mode .correlation-matrix {
            background: var(--border-dark);
        }

        .light-mode .correlation-cell {
            background: var(--bg-dark);
            color: var(--text-primary);
        }

        .light-mode .correlation-header {
            background: var(--bg-darker);
            color: var(--text-primary);
            font-weight: 600;
        }


        /* 라이트 모드 - 포트폴리오 구성 */
        .light-mode .chart-section {
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
        }

        .light-mode .chart-section h4 {
            color: var(--text-primary);
        }

        .light-mode .pie-chart-wrapper {
            background: var(--bg-dark);
            border: 1px solid var(--border-dark);
        }

        .light-mode .pie-chart-title {
            color: var(--text-primary);
        }

        .light-mode .legend-item {
            color: var(--text-primary);
        }

        .light-mode .rebalancing-metric {
            background: var(--bg-darker);
            border: 1px solid var(--border-dark);
        }

        .light-mode .rebalancing-metric .metric-title {
            color: var(--text-muted);
        }

        .light-mode .rebalancing-metric .metric-value {
            color: var(--text-primary);
        }

        /* 라이트 모드 - 차트 범례 강제 설정 */
        .light-mode .chart-section canvas {
            background: transparent !important;
        }

        /* Chart.js legend override */
        .light-mode .chartjs-legend,
        .light-mode .chartjs-legend-item,
        .light-mode .chartjs-legend-item-text {
            color: var(--text-primary) !important;
        }

        /* 헬퍼 클래스 - 인라인 스타일 대체 */
        .hint-text {
            color: var(--text-muted);
            font-size: 11px;
            margin-top: 4px;
            display: block;
        }

        .info-hint {
            color: var(--text-muted);
            font-size: 12px;
            margin-top: 4px;
            display: block;
        }

        .info-box {
            padding: 8px 12px;
            background: var(--bg-primary-alpha);
            border-left: 3px solid var(--color-primary);
            border-radius: 4px;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 12px;
            display: none;
        }

        .info-box.show {
            display: block;
        }

        /* ============================================
           라이트 모드 전면 오버라이드
           Tailwind dark: 프리픽스 무시하고 강제 적용
           ============================================ */

        /* 모든 제목과 텍스트를 검정색으로 강제 */
        .light-mode h1,
        .light-mode h2,
        .light-mode h3,
        .light-mode h4,
        .light-mode h5,
        .light-mode h6,
        .light-mode .header-title,
        .light-mode p,
        .light-mode span,
        .light-mode div,
        .light-mode label {
            color: #111827 !important;
        }

        /* 강조 색상 복원 - 빨강, 파랑, 초록 등 */
        .light-mode .text-red,
        .light-mode .positive,
        .light-mode .negative,
        .light-mode .text-green,
        .light-mode .text-blue,
        .light-mode .metric-value.positive,
        .light-mode .metric-value.negative,
        .light-mode .text-success,
        .light-mode .text-danger,
        .light-mode .text-warning,
        .light-mode .text-primary,
        .light-mode .color-primary,
        .light-mode .logout-btn {
            color: revert !important;
        }

        /* 버튼 텍스트 흰색 유지 */
        .light-mode .run-btn,
        .light-mode .run-btn *,
        .light-mode .compare-btn,
        .light-mode .compare-btn *,
        .light-mode .confirm-btn,
        .light-mode .confirm-btn *,
        .light-mode button.text-white,
        .light-mode button.text-white *,
        .light-mode .bg-blue-700,
        .light-mode .bg-blue-700 *,
        .light-mode .bg-blue-600,
        .light-mode .bg-blue-600 *,
        .light-mode .bg-red-700,
        .light-mode .bg-red-700 *,
        .light-mode .bg-red-600,
        .light-mode .bg-red-600 *,
        .light-mode .bg-green-700,
        .light-mode .bg-green-700 *,
        .light-mode .bg-green-600,
        .light-mode .bg-green-600 *,
        .light-mode .admin-btn.primary,
        .light-mode .admin-btn.primary *,
        .light-mode .admin-btn.danger,
        .light-mode .admin-btn.danger *,
        .light-mode button[class*="bg-blue"],
        .light-mode button[class*="bg-blue"] *,
        .light-mode button[class*="bg-red"],
        .light-mode button[class*="bg-red"] *,
        .light-mode button[class*="bg-green"],
        .light-mode button[class*="bg-green"] * {
            color: white !important;
        }

        /* 모든 카드/컨테이너 배경 */
        .light-mode .strategy-selector-content,
        .light-mode .settings-card,
        .light-mode .results-card,
        .light-mode .admin-login-content,
        .light-mode .data-management-content,
        .light-mode .yearly-table,
        .light-mode .metrics-table,
        .light-mode .selected-strategy-card {
            background: var(--bg-dark) !important;
            border-color: var(--border-dark) !important;
            color: var(--text-primary) !important;
        }

        /* 전략 아이템 (목록) */
        .light-mode .strategy-item {
            background: transparent !important;
            color: var(--text-primary) !important;
        }

        .light-mode .strategy-item:hover {
            background: var(--bg-hover) !important;
        }

        /* 입력 필드들 */
        .light-mode input[type="month"],
        .light-mode input[type="text"],
        .light-mode input[type="password"],
        .light-mode select,
        .light-mode .form-input {
            background: var(--bg-secondary) !important;
            border-color: var(--border-medium) !important;
            color: var(--text-primary) !important;
        }

        .light-mode input::placeholder,
        .light-mode select::placeholder {
            color: var(--text-tertiary) !important;
        }

        /* 버튼들 */
        .light-mode .quick-date-btn,
        .light-mode .admin-btn.cancel,
        .light-mode .admin-btn.secondary {
            background: var(--bg-secondary) !important;
            border-color: var(--border-medium) !important;
            color: var(--text-primary) !important;
        }

        .light-mode .quick-date-btn:hover,
        .light-mode .admin-btn.cancel:hover,
        .light-mode .admin-btn.secondary:hover {
            background: var(--bg-hover) !important;
        }

        /* 구글 로그인 버튼 */
        .light-mode .google-signin-btn {
            background: var(--bg-dark) !important;
            border-color: var(--border-medium) !important;
            color: var(--text-primary) !important;
        }

        .light-mode .google-signin-btn:hover {
            background: var(--bg-secondary) !important;
        }

        /* 체크박스 */
        .light-mode .strategy-checkbox {
            background: var(--bg-dark) !important;
            border: 2px solid var(--border-medium) !important;
            width: 20px !important;
            height: 20px !important;
            cursor: pointer !important;
            appearance: none !important;
            -webkit-appearance: none !important;
            border-radius: 4px !important;
            position: relative !important;
        }

        /* 체크박스 체크된 상태 */
        .light-mode .strategy-checkbox:checked {
            background: var(--color-primary) !important;
            border-color: var(--color-primary) !important;
        }

        /* 체크 표시 (✓) */
        .light-mode .strategy-checkbox:checked::after {
            content: '✓' !important;
            position: absolute !important;
            color: white !important;
            font-size: 16px !important;
            font-weight: bold !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }

        /* 체크박스 호버 효과 */
        .light-mode .strategy-checkbox:hover {
            border-color: var(--color-primary) !important;
        }

        /* 테이블 */
        .light-mode .yearly-table th,
        .light-mode .yearly-table td,
        .light-mode .metrics-table th,
        .light-mode .metrics-table td {
            background: var(--bg-dark) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-dark) !important;
        }

        .light-mode .yearly-table th,
        .light-mode .metrics-table th {
            background: var(--bg-secondary) !important;
        }

        .light-mode .yearly-table tbody tr:nth-child(even),
        .light-mode .metrics-table tbody tr:nth-child(even) {
            background: var(--bg-secondary) !important;
        }

        .light-mode .yearly-table tr:hover td,
        .light-mode .metrics-table tr:hover td {
            background: var(--bg-hover) !important;
        }

        /* 투자 유의사항 텍스트 색상 개선 */
        .light-mode .disclaimer {
            color: var(--text-primary) !important;
        }

        .light-mode .disclaimer h2 {
            color: var(--text-primary) !important;
        }

        .light-mode .disclaimer p,
        .light-mode .disclaimer li {
            color: var(--text-secondary) !important;
        }

        /* 모달 오버레이 */
        .light-mode .modal-overlay {
            background: var(--bg-overlay) !important;
        }

        /* 전략 카드 내부 텍스트 */
        .light-mode .strategy-name,
        .light-mode .strategy-creator,
        .light-mode .strategy-description {
            color: var(--text-primary) !important;
        }

        /* 분석 화면 배경 */
        .light-mode .analysis-screen {
            background: var(--bg-primary) !important;
        }

        /* 선택 화면 배경 */
        .light-mode .selection-screen {
            background: var(--bg-primary) !important;
        }

    </style>
</head>
<body>

    <!-- 햄버거 메뉴 버튼 -->
    <div class="menu-button" id="menu-button" onclick="toggleMenu()">
        <div class="menu-line"></div>
        <div class="menu-line"></div>
        <div class="menu-line"></div>
    </div>

    <!-- 메뉴 오버레이 -->
    <div class="menu-overlay" id="menu-overlay" onclick="closeMenu()"></div>
    <!-- 관리자 로그인 모달 -->
    <div class="admin-login-modal" id="admin-login-modal">
        <div class="admin-login-content bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-xl">
            <h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">관리자 로그인</h3>
            <div class="form-group">
                <label class="form-label">비밀번호</label>
                <input type="password" class="form-input bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 transition-all duration-300" id="admin-password" placeholder="관리자 비밀번호를 입력하세요">
            </div>
            <div class="admin-login-buttons">
                <button class="admin-btn cancel text-gray-900 bg-white border border-gray-300 focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-100 font-medium rounded-lg text-sm px-5 py-2.5 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700 transition-all duration-300" onclick="closeAdminLogin()">취소</button>
                <button class="admin-btn confirm text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 transition-all duration-300" onclick="confirmAdminLogin()">로그인</button>
            </div>
        </div>
    </div>

    <!-- 데이터 관리 모달 -->
    <div class="data-management-modal" id="data-management-modal">
        <div class="data-management-content bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-xl">
            <div class="data-management-header">
                <h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">데이터 관리 (관리자)</h3>
                <button class="close-btn text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm w-8 h-8 inline-flex justify-center items-center dark:hover:bg-gray-600 dark:hover:text-white transition-all duration-300" onclick="closeDataManagement()">×</button>
            </div>
            
            <div class="data-management-section">
                <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">통합 데이터 업로드</h4>
                <div class="upload-area" id="unified-upload-area">
                    <input type="file" id="unified-file-input" accept=".xlsx,.xls" style="display: none;" onchange="handleUnifiedFile(event)">
                    <div class="upload-placeholder" onclick="document.getElementById('unified-file-input').click()">
                        <div class="upload-icon">📊</div>
                        <div class="upload-text">통합 데이터 엑셀 파일을 선택하세요</div>
                        <div class="upload-subtext">전략 정보, 자산 배분, ETF 가격 데이터를 포함한 하나의 파일</div>
                    </div>
                </div>
            </div>
            
            <div class="data-management-section">
                <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">현재 데이터 상태</h4>
                <div class="data-status">
                    <div class="status-item">
                        <span class="status-label">등록된 전략:</span>
                        <span class="status-value" id="strategy-count">0개</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">ETF 데이터:</span>
                        <span class="status-value" id="etf-data-status">없음</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">마지막 업데이트:</span>
                        <span class="status-value" id="last-update">없음</span>
                    </div>
                </div>
                
                <div class="data-actions">
                    <button class="admin-btn danger text-white bg-red-700 hover:bg-red-800 focus:ring-4 focus:outline-none focus:ring-red-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:bg-red-600 dark:hover:bg-red-700 dark:focus:ring-red-900 transition-all duration-300" onclick="clearAllData()">모든 데이터 삭제</button>
                    <button class="admin-btn secondary text-gray-900 bg-gray-100 border border-gray-300 focus:outline-none hover:bg-gray-200 focus:ring-4 focus:ring-gray-100 font-medium rounded-lg text-sm px-5 py-2.5 dark:bg-gray-700 dark:text-white dark:border-gray-600 dark:hover:bg-gray-600 dark:focus:ring-gray-700 transition-all duration-300" onclick="exportData()">데이터 내보내기 (JSON)</button>
                    <button class="admin-btn primary text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-900 transition-all duration-300" onclick="exportToExcel()">엑셀로 내보내기</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 사이드 메뉴 -->
        <div class="side-menu" id="side-menu">
            <!-- 구글 로그인 섹션 -->
            <div class="google-login-section">
                <div id="google-login-container">
                    <div class="login-prompt" id="login-prompt">
                        <button class="google-signin-btn w-full text-gray-900 bg-white hover:bg-gray-100 border border-gray-200 focus:ring-4 focus:outline-none focus:ring-gray-100 font-medium rounded-lg text-sm px-5 py-2.5 text-center inline-flex items-center justify-center dark:focus:ring-gray-600 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:hover:bg-gray-700 transition-all duration-300" id="google-signin-btn" onclick="signInWithGoogle()">
                            <svg class="google-icon" viewBox="0 0 24 24" width="20" height="20">
                                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                            </svg>
                            <span>Sign in with Google</span>
                        </button>
                    </div>
                    <div class="user-profile" id="user-profile" style="display: none;">
                        <div class="user-avatar" id="user-avatar">
                            <img id="user-avatar-img" src="" alt="사용자 아바타">
                        </div>
                        <div class="user-info">
                            <div class="user-name" id="user-name"></div>
                            <div class="user-email" id="user-email"></div>
                        </div>
                        <button class="logout-btn text-white bg-red-600 hover:bg-red-700 focus:ring-4 focus:outline-none focus:ring-red-300 font-medium rounded-lg text-xs px-3 py-1.5 text-center dark:bg-red-500 dark:hover:bg-red-600 dark:focus:ring-red-900 transition-all duration-300" onclick="signOut()">로그아웃</button>
                    </div>
                </div>
            </div>

            <!-- 프로필 섹션 -->
            <div class="menu-section">
            <div class="menu-title">프로필</div>
            <div class="menu-item" onclick="editProfile()">
                <div class="menu-item-label">사용자 설정</div>
                <div class="menu-item-value">편집 ></div>
            </div>
            <div class="menu-item" onclick="viewHistory()">
                <div class="menu-item-label">분석 기록</div>
                <div class="menu-item-value">보기 ></div>
            </div>
            <div class="menu-item" onclick="manageFavorites()">
                <div class="menu-item-label">즐겨찾기 전략</div>
                <div class="menu-item-value" id="favorites-count">0개</div>
            </div>
        </div>

        <!-- 모드 설정 -->
        <div class="menu-section">
            <div class="menu-title">화면 설정</div>
            <div class="menu-item">
                <div class="menu-item-label">다크 모드</div>
                <div class="toggle-switch active" id="dark-mode-toggle" onclick="toggleDarkMode()">
                    <div class="toggle-slider"></div>
                </div>
            </div>
        </div>

        <!-- 기타 설정 -->
        <div class="menu-section">
            <div class="menu-title">기타</div>
            <div class="menu-item" onclick="showTutorial(); closeMenu();">
                <div class="menu-item-label">튜토리얼 다시 보기</div>
                <div class="menu-item-value">🎓</div>
            </div>
            <div class="menu-item" onclick="showHelp()">
                <div class="menu-item-label">도움말</div>
                <div class="menu-item-value">></div>
            </div>
            <div class="menu-item" onclick="showAbout()">
                <div class="menu-item-label">앱 정보</div>
                <div class="menu-item-value">v1.0.0</div>
            </div>
            <div class="menu-item" onclick="contactSupport()">
                <div class="menu-item-label">문의하기</div>
                <div class="menu-item-value">></div>
            </div>
            <!-- 관리자 설정 -->
            <div class="menu-section" id="admin-menu-section" style="display: none;">
                <div class="menu-title">관리자</div>
                <div class="menu-item" onclick="openDataManagement()">
                    <div class="menu-item-label">데이터 관리</div>
                    <div class="menu-item-value">></div>
                </div>
                <div class="menu-item" onclick="logoutAdmin()">
                    <div class="menu-item-label">관리자 로그아웃</div>
                    <div class="menu-item-value">></div>
                </div>
            </div>

            <!-- 관리자 로그인 -->
            <div class="menu-section" id="admin-login-section">
                <div class="menu-title">관리자</div>
                <div class="menu-item" onclick="showAdminLogin()">
                    <div class="menu-item-label">관리자 로그인</div>
                    <div class="menu-item-value">></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 1단계: 홈 화면 (구글 스타일) -->
    <div class="home-screen" id="home-screen">
        <div class="logo text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400">Then, Follow</div>
        
        <div class="search-container">
            <input type="text" class="search-box" placeholder="투자 전략 검색 또는 선택..."
                   id="search-input" autocomplete="off" readonly onclick="openStrategySelector()">
            


            <!-- 전략 선택 모달 -->
            <div class="strategy-selector-modal" id="strategy-selector-modal">
                <div class="strategy-selector-content bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-xl">
                    <div class="selector-header">
                        <h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">전략 선택 (복수 선택 가능)</h3>
                        <button class="close-btn text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm w-8 h-8 inline-flex justify-center items-center dark:hover:bg-gray-600 dark:hover:text-white transition-all duration-300" onclick="closeStrategySelector()">×</button>
                    </div>
                    
                    <div class="search-filter">
                        <input type="text" placeholder="전략명 검색..." id="strategy-search" onkeyup="filterStrategies()">
                    </div>
                    
                    <div class="strategy-list" id="strategy-list">
                        <!-- 전략 목록이 여기에 표시됩니다 -->
                    </div>
                    
                    <div class="selector-footer">
                        <div class="selected-count" id="selected-count">0개 선택됨</div>
                        <button class="confirm-btn text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 transition-all duration-300" onclick="confirmStrategySelection()">선택 완료</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 항목별 최고 전략 찾기 -->
        <div class="performance-buttons">
            <h3 class="section-title">성과별 최고 전략 찾기 (최근 1년)</h3>
            <div class="performance-grid">
                <button class="performance-btn" onclick="findBestStrategies('total_return')">
                    <div class="btn-icon">📈</div>
                    <div class="btn-text">최고 수익률</div>
                </button>
                <button class="performance-btn" onclick="findBestStrategies('low_risk')">
                    <div class="btn-icon">🛡️</div>
                    <div class="btn-text">최저 위험도</div>
                </button>
                <button class="performance-btn" onclick="findBestStrategies('sharpe_ratio')">
                    <div class="btn-icon">⚖️</div>
                    <div class="btn-text">최고 샤프비율</div>
                </button>
                <button class="performance-btn" onclick="findBestStrategies('win_rate')">
                    <div class="btn-icon">🎯</div>
                    <div class="btn-text">최고 승률</div>
                </button>
            </div>
        </div>

        <div class="disclaimer">
            <h4 class="disclaimer-title">투자 유의사항</h4>
            <p class="disclaimer-text">
                본 서비스는 과거 데이터 기반의 백테스트 결과를 제공하는 교육 목적의 도구입니다.<br>
                과거 성과가 미래 수익을 보장하지 않으며, 모든 투자에는 원금 손실 위험이 있습니다.<br>
                본 정보는 투자 권유, 매매 추천 또는 금융 자문이 아닙니다.<br>
                투자 결정 전 반드시 전문가와 상담하시기 바랍니다.
            </p>
        </div>

    </div>

    <!-- 첫 방문자 튜토리얼 -->
    <div class="tutorial-overlay" id="tutorial-overlay">
        <div class="tutorial-content">
            <div class="tutorial-header">
                <h3 id="tutorial-title">Then, Follow에 오신 것을 환영합니다!</h3>
                <button class="close-btn text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm w-8 h-8 inline-flex justify-center items-center dark:hover:bg-gray-600 dark:hover:text-white transition-all duration-300" onclick="closeTutorial()">×</button>
            </div>
            <div class="tutorial-body">
                <div class="tutorial-step" id="tutorial-step-1">
                    <div class="tutorial-icon">🎯</div>
                    <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">1단계: 전략 선택</h4>
                    <p>검색창을 클릭하거나 "성과별 최고 전략 찾기" 버튼을 사용하여 비교하고 싶은 투자 전략들을 선택하세요.</p>
                    <p class="tutorial-tip">💡 최대 10개의 전략을 동시에 비교할 수 있습니다!</p>
                </div>
                <div class="tutorial-step hidden" id="tutorial-step-2">
                    <div class="tutorial-icon">📅</div>
                    <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">2단계: 기간 설정</h4>
                    <p>백테스트할 기간을 선택하세요. 빠른 선택 버튼(최근 1년, 3년, 5년 등)을 사용하거나 직접 날짜를 입력할 수 있습니다.</p>
                    <p class="tutorial-tip">💡 기간이 길수록 전략의 장기 성과를 파악할 수 있습니다.</p>
                </div>
                <div class="tutorial-step hidden" id="tutorial-step-3">
                    <div class="tutorial-icon">📊</div>
                    <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">3단계: 결과 분석</h4>
                    <p>수익률 차트, 드로다운 분석, 월별 히트맵 등 다양한 지표를 통해 전략을 심층 분석하세요.</p>
                    <p class="tutorial-tip">💡 지표 옆 <strong>?</strong> 아이콘을 클릭하면 상세 설명을 볼 수 있습니다!</p>
                </div>
                <div class="tutorial-step hidden" id="tutorial-step-4">
                    <div class="tutorial-icon">💡</div>
                    <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">유용한 팁</h4>
                    <ul class="tutorial-tips-list">
                        <li>파이 차트의 ETF를 클릭하면 자세한 정보를 볼 수 있습니다</li>
                        <li>햄버거 메뉴(☰)에서 다크/라이트 모드를 전환할 수 있습니다</li>
                    </ul>
                </div>
            </div>
            <div class="tutorial-footer">
                <div class="tutorial-progress">
                    <span class="progress-dot active" data-step="1"></span>
                    <span class="progress-dot" data-step="2"></span>
                    <span class="progress-dot" data-step="3"></span>
                    <span class="progress-dot" data-step="4"></span>
                </div>
                <div class="tutorial-buttons">
                    <label class="tutorial-checkbox">
                        <input type="checkbox" id="tutorial-dont-show">
                        <span>다시 보지 않기</span>
                    </label>
                    <div>
                        <button class="tutorial-btn tutorial-prev hidden" onclick="prevTutorialStep()">이전</button>
                        <button class="tutorial-btn tutorial-next" onclick="nextTutorialStep()">다음</button>
                        <button class="tutorial-btn tutorial-finish hidden" onclick="finishTutorial()">시작하기</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 2단계: 선택 화면 -->
    <div class="selection-screen" id="selection-screen">
        <div class="header">
            <button class="back-btn" onclick="goToHome()">←</button>
            <div class="header-title text-3xl font-bold text-gray-900 dark:text-white mb-4">전략 비교</div>
        </div>
        
        <div class="selected-strategies" id="selected-strategies">
            <!-- 선택된 전략들이 여기에 표시됩니다 -->
        </div>
        
        <button class="add-more-btn" onclick="goToHome()">
            + 다른 전략 추가하기
        </button>
        
        <button class="compare-btn" id="compare-btn" onclick="goToAnalysis()" disabled>
            백테스트 분석 시작
        </button>
    </div>

    <!-- 3단계: 분석 화면 -->
    <div class="analysis-screen" id="analysis-screen">
        <div class="header">
            <button class="back-btn" onclick="goToSelection()">←</button>
            <div class="header-title text-3xl font-bold text-gray-900 dark:text-white mb-4">백테스트 분석</div>
        </div>

        
        <div class="section">
            <div class="section-title text-2xl font-semibold text-gray-900 dark:text-white mb-3">백테스트 설정</div>
            <div class="settings-card bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                <!-- 빠른 기간 선택 버튼 -->
                <div class="form-group">
                    <label class="form-label">빠른 기간 선택</label>
                    <div class="quick-date-buttons" style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px;">
                        <button class="quick-date-btn text-gray-900 bg-white border border-gray-300 focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-100 font-medium rounded-lg text-sm px-4 py-2 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700 transition-all duration-300" onclick="setQuickDate(1, event)">최근 1년</button>
                        <button class="quick-date-btn text-gray-900 bg-white border border-gray-300 focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-100 font-medium rounded-lg text-sm px-4 py-2 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700 transition-all duration-300" onclick="setQuickDate(3, event)">최근 3년</button>
                        <button class="quick-date-btn text-gray-900 bg-white border border-gray-300 focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-100 font-medium rounded-lg text-sm px-4 py-2 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700 transition-all duration-300" onclick="setQuickDate(5, event)">최근 5년</button>
                        <button class="quick-date-btn text-gray-900 bg-white border border-gray-300 focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-100 font-medium rounded-lg text-sm px-4 py-2 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700 transition-all duration-300" onclick="setQuickDate(10, event)">최근 10년</button>
                        <button class="quick-date-btn text-gray-900 bg-white border border-gray-300 focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-100 font-medium rounded-lg text-sm px-4 py-2 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700 transition-all duration-300" onclick="setQuickDate(20, event)">최근 20년</button>
                    </div>
                </div>

                <div class="form-grid">
                    <div class="form-group">
                        <label class="form-label">시작 월</label>
                        <input type="month" class="form-input bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 transition-all duration-300" id="start-date" value="2020-01">
                        <small id="start-date-hint" class="hint-text">해당 월의 마지막 영업일 기준</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">종료 월</label>
                        <input type="month" class="form-input bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 transition-all duration-300" id="end-date" value="2025-03">
                        <small id="end-date-hint" class="hint-text">해당 월의 마지막 영업일 기준</small>
                    </div>
                </div>
                <div id="date-range-info" class="info-box">
                    <span id="date-range-message"></span>
                </div>
                
                <div class="form-group">
                    <label class="form-label">리밸런싱 주기 (전체 적용)</label>
                    <select class="form-input bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 transition-all duration-300" id="user-rebalancing-override">
                        <option value="monthly">월간(1개월마다)</option>
                        <option value="quarterly" selected>분기별(3개월마다)</option>
                        <option value="semiannual">반기별(6개월마다)</option>
                        <option value="annual">연간(12개월마다)</option>
                        <option value="none">리밸런싱 없음(Buy & Hold)</option>
                    </select>
                    <small class="info-hint">
                        선택한 모든 전략에 동일하게 적용됩니다.
                    </small>
                </div>
                
                <button class="run-btn" id="run-backtest-btn" onclick="runBacktest()">
                    <span id="run-backtest-btn-text">백테스트 실행</span>
                    <div id="run-backtest-btn-spinner" class="loading-spinner small" style="display: none;"></div>
                </button>
                
                <!-- 프로그레스 바 -->
                <div id="backtest-progress" style="display: none; margin-top: 16px;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill" style="width: 0%;"></div>
                    </div>
                    <div class="progress-text" id="progress-text">준비 중...</div>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title text-2xl font-semibold text-gray-900 dark:text-white mb-3">백테스트 가정</div>
            <div class="settings-card bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-md hover:shadow-lg transition-all duration-300">
                <div class="backtest-assumptions">
                    <div class="assumption-item">
                        <div class="assumption-value">0.20%</div>
                        <div class="assumption-label">거래 비용(매수+매도)</div>
                    </div>
                    <div class="assumption-item">
                        <div class="assumption-value">2.0%</div>
                        <div class="assumption-label">현금 수익률</div>
                    </div>
                    <div class="assumption-item">
                        <div class="assumption-value">재투자</div>
                        <div class="assumption-label">배당 처리</div>
                    </div>
                    <div class="assumption-item">
                        <div class="assumption-value">장 마감</div>
                        <div class="assumption-label">거래 시점</div>
                    </div>
                </div>
            </div>
        </div>



        <div class="section">
            <div class="results-card bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-md transition-all duration-300" id="results-card">
                <div class="section-title text-2xl font-semibold text-gray-900 dark:text-white mb-3">분석 결과</div>
                
                <!-- 로딩 상태 -->
                <div class="loading-overlay" id="chart-loading">
                    <div class="loading-content">
                        <div class="loading-spinner"></div>
                        <div class="loading-title">차트 생성 중</div>
                        <div class="loading-subtitle">데이터를 분석하고 시각화하고 있습니다...</div>
                    </div>
                </div>
                
                <!-- 실제 차트 -->
                <div id="chart-content" style="display: none;">
                    <!-- 차트 컨트롤 -->
                    <div class="chart-controls">
                        <div class="chart-actions">
                            <button class="action-btn" onclick="resetChartZoom()" title="차트 확대/축소 초기화">
                                <span class="btn-icon">🔍</span>
                                <span class="btn-text">초기화</span>
                            </button>
                            <button class="action-btn" onclick="downloadChart()" title="차트 이미지 다운로드">
                                <span class="btn-icon">💾</span>
                                <span class="btn-text">저장</span>
                            </button>
                            <button class="action-btn" onclick="exportDetailedReport()">
                                <span class="btn-icon">📊</span>
                                <span class="btn-text">리포트</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="chart-container chart-interactive">
                        <canvas id="comparison-chart"></canvas>
                        <div class="chart-info-overlay" id="chart-info-overlay">
                            <!-- 클릭한 데이터 포인트 정보가 여기에 표시됩니다 -->
                        </div>
                    </div>
                    
                    <!-- 상세 분석 탭 -->
                    <div class="analysis-tabs">
                        <button class="tab-button active" onclick="switchTab('overview')">개요</button>
                        <button class="tab-button" onclick="switchTab('portfolio')">포트폴리오 구성</button>
                        <button class="tab-button" onclick="switchTab('yearly')">연도별 성과</button>
                        <button class="tab-button" onclick="switchTab('advanced')">고급 분석</button>
                        <button class="tab-button" onclick="switchTab('detailed')">상세 지표</button>
                    </div>
                    
                    <!-- 개요 탭 -->
                    <div class="tab-content active" id="overview-tab">
                        <div class="metrics-grid" id="metrics-grid">
                            <!-- 기본 결과 지표들이 여기에 표시됩니다 -->
                        </div>
                    </div>
                    
                    <!-- 포트폴리오 구성 탭 -->
                    <div class="tab-content" id="portfolio-tab">

                        <!-- 파이차트 섹션 -->
                        <div class="portfolio-charts">
                            <div class="chart-section">
                                <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">자산 배분 구성</h4>
                                <div class="pie-charts-container" id="pie-charts-container">
                                    <!-- 파이차트들이 여기에 동적으로 생성됩니다 -->
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- 연도별 성과 탭 -->
                    <div class="tab-content" id="yearly-tab">
                        <div class="yearly-performance">
                            <table class="yearly-table w-full text-sm text-left text-gray-500 dark:text-gray-400 border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800" id="yearly-table">
                                <thead>
                                    <tr>
                                        <th>전략</th>
                                        <th>2020</th>
                                        <th>2021</th>
                                        <th>2022</th>
                                        <th>2023</th>
                                        <th>누적</th>
                                    </tr>
                                </thead>
                                <tbody id="yearly-table-body">
                                    <!-- 동적 생성 -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="tab-content" id="advanced-tab">
                        <div class="chart-section">
                            <h4 class="text-lg font-medium text-gray-900 dark:text-white mb-2">드로다운 분석</h4>
                            <div class="chart-container">
                                <canvas id="drawdown-chart"></canvas>
                            </div>
                        </div>

                        <div class="chart-section">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                <h4 style="margin: 0;">월별 수익률 히트맵</h4>
                                <div style="display: flex; gap: 8px; flex-wrap: wrap;" id="heatmap-strategy-selector">
                                    <!-- 전략 선택 버튼이 동적으로 생성됩니다 -->
                                </div>
                            </div>
                            <div id="monthly-heatmap"></div>
                        </div>

                        <div class="chart-section">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                <h4 style="margin: 0;">전략 간 상관관계 매트릭스</h4>
                                <div style="display: flex; gap: 8px; flex-wrap: wrap;" id="correlation-strategy-selector">
                                    <!-- 전략 선택 버튼이 동적으로 생성됩니다 -->
                                </div>
                            </div>
                            <div id="correlation-matrix" class="correlation-matrix">
                                <!-- 동적 생성 -->
                            </div>
                        </div>
                    </div>

                    <!-- 상세 지표 탭 -->
                    <div class="tab-content" id="detailed-tab">
                        <table class="metrics-table w-full text-sm text-left text-gray-500 dark:text-gray-400 border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800" id="detailed-metrics-table">
                            <thead>
                                <tr>
                                    <th>지표</th>
                                    <th id="detailed-headers"><!-- 동적 생성 --></th>
                                </tr>
                            </thead>
                            <tbody id="detailed-metrics-body">
                                <!-- 동적 생성 -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 알림 시스템 -->
    <div class="notification" id="notification"></div>
    <!-- 구글 로그인 상태 표시기 -->
    <div class="login-status" id="login-status"></div>

    <!-- 지표 설명 툴팁 -->
    <div class="metric-tooltip" id="metric-tooltip">
        <div class="tooltip-title" id="tooltip-title"></div>
        <div class="tooltip-description" id="tooltip-description"></div>
        <div class="tooltip-formula" id="tooltip-formula"></div>
        <div class="tooltip-interpretation" id="tooltip-interpretation"></div>
    </div>

    <script type="text/javascript">
        // @ts-nocheck
        /* eslint-disable */
        if (typeof Chart === 'undefined') {
            console.error('Chart.js가 로드되지 않았습니다.');
            document.body.innerHTML = '<div style="text-align:center; padding:50px;">Chart.js 라이브러리를 로드할 수 없습니다. 인터넷 연결을 확인해주세요.</div>';
        }

        // 전역 변수들
        let selectedStrategies = [];
        let comparisonChart;
        let benchmarkChart;
        let pieCharts = [];
        let isDarkMode = true;
        let favoriteStrategies = [];
        let currentPeriod = 3;
        let chartData = { labels: [], datasets: [] };
        let backtestResults = {}; // 각 전략의 백테스트 결과 저장
        let portfolioTimeSeries = {}; // 각 전략의 시계열 데이터 저장
        const backtestCache = new Map();
        const strategyPreviewCache = new Map(); // 전략 프리뷰 캐시

        // 백테스트 가정 (Allocate Smartly 기준)
        const BACKTEST_ASSUMPTIONS = {
            tradingCostPerTrade: 0.001,      // 0.10% per trade
            roundTripCost: 0.002,             // 0.20% round-trip (매수+매도)
            cashReturnRate: 0.02,             // 2% 연간 (3개월 국채 근사치)
            dividendReinvest: true,           // 배당 재투자
            rebalancingDay: 'month-end',      // 월말 리밸런싱
            executionTime: 'close'            // 장 마감 시
        };

        // ETF 정보 데이터
        const etfInfo = {
            'VTI': {
                name: 'Vanguard 전체 주식시장',
                category: '미국 주식',
                expense: '0.03%',
                description: '미국 주식 시장 전체(대형주, 중형주, 소형주)를 추종하는 ETF입니다. 약 4,000개 이상의 종목에 분산 투자되어 있어 미국 경제 전반의 성장을 따라갑니다.'
            },
            'SPY': {
                name: 'S&P 500',
                category: '미국 대형주',
                expense: '0.09%',
                description: '미국 대형주 500개 기업으로 구성된 S&P 500 지수를 추종합니다. 가장 유동성이 높고 거래량이 많은 대표적인 미국 주식 ETF입니다.'
            },
            'VOO': {
                name: 'Vanguard S&P 500',
                category: '미국 대형주',
                expense: '0.03%',
                description: 'SPY와 동일하게 S&P 500 지수를 추종하지만 운용 보수가 더 낮습니다. 장기 투자자에게 유리한 선택입니다.'
            },
            'VXUS': {
                name: 'Vanguard 해외 주식',
                category: '해외 주식',
                expense: '0.07%',
                description: '미국을 제외한 전 세계 선진국과 신흥국 주식에 투자합니다. 지역 분산을 통해 미국 시장 리스크를 헷지할 수 있습니다.'
            },
            'BND': {
                name: 'Vanguard 전체 채권',
                category: '미국 채권',
                expense: '0.03%',
                description: '미국 투자등급 채권 시장 전체를 추종합니다. 국채, 회사채, MBS 등 다양한 채권에 분산 투자되어 있어 안정적인 수익을 추구합니다.'
            },
            'TLT': {
                name: '20년+ 미국 국채',
                category: '장기 국채',
                expense: '0.15%',
                description: '만기 20년 이상의 미국 장기 국채에 투자합니다. 금리 변동에 민감하며, 경기 침체 시 안전자산으로서 주식과 음의 상관관계를 보입니다.'
            },
            'IEF': {
                name: '7-10년 미국 국채',
                category: '중기 국채',
                expense: '0.15%',
                description: '만기 7-10년의 중기 미국 국채에 투자합니다. 장기채보다 금리 변동성이 낮으면서도 적절한 수익률을 제공합니다.'
            },
            'SHY': {
                name: '1-3년 미국 국채',
                category: '단기 국채',
                expense: '0.15%',
                description: '만기 1-3년의 단기 미국 국채에 투자합니다. 변동성이 매우 낮아 현금성 자산 대용으로 활용됩니다.'
            },
            'GLD': {
                name: 'SPDR 금',
                category: '금',
                expense: '0.40%',
                description: '금 현물 가격을 추종하는 ETF입니다. 인플레이션 헷지와 포트폴리오 분산 효과를 제공하며, 주식/채권과 낮은 상관관계를 가집니다.'
            },
            'DBC': {
                name: 'Invesco 원자재',
                category: '원자재',
                expense: '0.87%',
                description: '에너지, 농산물, 귀금속 등 다양한 원자재 선물에 투자합니다. 인플레이션 보호와 포트폴리오 다변화 목적으로 사용됩니다.'
            },
            'VNQ': {
                name: 'Vanguard 리츠',
                category: '부동산',
                expense: '0.12%',
                description: '미국 부동산 투자 신탁(REITs)에 투자합니다. 배당 수익률이 높고 인플레이션 헷지 효과가 있으며, 주식/채권과 상관관계가 낮습니다.'
            }
        };

        // 지표 설명 데이터
        const metricExplanations = {
            totalReturn: {
                title: '누적 수익률 (Total Return)',
                description: '투자 기간 동안 발생한 전체 수익률입니다. 복리 효과가 반영된 최종 수익률로, 배당 재투자와 리밸런싱 비용(0.2%)이 모두 포함됩니다. 누적 수익률은 투자 기간에 따라 달라지므로 연평균 수익률(CAGR)과 함께 확인해야 합니다.',
                interpretation: {
                    high: '연환산 15% 이상이면 매우 우수한 성과입니다.',
                    medium: '연환산 7~15%는 양호한 수준입니다.',
                    low: '연환산 7% 미만은 보통 수준입니다.'
                },
                formula: '(최종 가치 - 초기 투자액) / 초기 투자액 × 100\n예: $10,000 투자 → $13,000 = +30.0%'
            },
            annualReturn: {
                title: '연평균 수익률 (CAGR)',
                description: '복리 효과를 고려한 연간 평균 수익률입니다. Compound Annual Growth Rate로, 투자 기간을 연 단위로 환산한 기하평균 수익률입니다.',
                interpretation: {
                    high: '15% 이상이면 탁월한 성과입니다.',
                    medium: '7~15%는 우수한 수준입니다.',
                    low: '7% 미만은 보통 수준입니다.'
                },
                formula: '((최종 가치 / 초기 가치)^(1/연수) - 1) × 100\n예: 3년간 $10,000 → $13,310 = 10.0%/년'
            },
            maxDrawdown: {
                title: '최대 낙폭 (MDD)',
                description: '투자 기간 중 고점 대비 최대 하락폭입니다. Maximum Drawdown으로, 투자자가 경험할 수 있는 최대 손실 폭을 나타냅니다.',
                interpretation: {
                    high: '-10% 이하면 매우 안전합니다.',
                    medium: '-10~-20%는 적당한 위험입니다.',
                    low: '-20% 이상은 높은 위험입니다.'
                },
                formula: '(최저점 - 최고점) / 최고점 × 100\n예: 고점 $11,000 → 최저 $9,000 = -18.2%'
            },
            sharpeRatio: {
                title: '샤프 비율 (Sharpe Ratio)',
                description: '위험 대비 초과 수익률을 측정하는 지표입니다. "변동성 1%를 감수할 때 무위험 수익률(국채) 대비 몇 %의 추가 수익을 얻는가"를 나타냅니다. 높을수록 같은 위험에서 더 많은 수익을 얻는 효율적인 투자입니다. 무위험 수익률은 연 2%를 가정합니다.',
                interpretation: {
                    high: '2.0 이상이면 매우 우수합니다.',
                    medium: '1.0~2.0은 양호한 수준입니다.',
                    low: '1.0 미만은 위험 대비 수익이 낮습니다.'
                },
                formula: '(연평균 수익률 - 무위험 수익률 2%) / 연간 변동성\n예: (10% - 2%) / 8% = 1.0'
            },
            volatility: {
                title: '변동성 (Volatility)',
                description: '월별 수익률의 표준편차를 연간으로 환산한 값입니다. 수익률이 얼마나 들쭉날쭉한지를 나타내며, 높을수록 위험이 큽니다.',
                interpretation: {
                    high: '10% 이하면 안정적입니다.',
                    medium: '10~20%는 보통 수준입니다.',
                    low: '20% 이상은 변동성이 높습니다.'
                },
                formula: '월별 수익률의 표준편차 × √12 (연간 환산)\n예: 월 표준편차 2.3% → 연간 = 8.0%'
            },
            calmarRatio: {
                title: '칼마 비율 (Calmar Ratio)',
                description: '연평균 수익률을 최대낙폭의 절댓값으로 나눈 비율입니다. 낙폭 대비 수익을 측정하며, 높을수록 하락 위험 대비 수익이 좋습니다.',
                interpretation: {
                    high: '1.0 이상이면 우수합니다.',
                    medium: '0.5~1.0은 양호합니다.',
                    low: '0.5 미만은 개선이 필요합니다.'
                },
                formula: '연평균 수익률 / |최대낙폭|\n예: 10% CAGR / 20% MDD = 0.5'
            },
            winRate: {
                title: '승률 (Win Rate)',
                description: '월 단위로 측정한 양의 수익률을 기록한 개월 수의 비율입니다. 높을수록 안정적으로 수익을 내는 전략입니다.',
                interpretation: {
                    high: '70% 이상이면 매우 안정적입니다.',
                    medium: '50~70%는 보통입니다.',
                    low: '50% 미만은 변동성이 큽니다.'
                },
                formula: '(양의 수익률 개월 수 / 전체 개월 수) × 100\n예: 12개월 중 8개월 상승 = 66.7%'
            },
            sortinoRatio: {
                title: '소르티노 비율 (Sortino Ratio)',
                description: '하방 위험 대비 초과 수익률을 측정합니다. 샤프 비율과 유사하지만 하락 변동성만 고려하므로, 상승 변동성이 큰 공격적 전략에 더 적합합니다.',
                interpretation: {
                    high: '2.0 이상이면 매우 우수합니다.',
                    medium: '1.0~2.0은 양호한 수준입니다.',
                    low: '1.0 미만은 하방 위험 대비 수익이 낮습니다.'
                },
                formula: '(연평균 수익률 - 무위험 수익률) / 하방 편차\n하방 편차 = 음의 수익률만으로 계산한 표준편차'
            },
            beta: {
                title: '베타 (Beta)',
                description: '시장(S&P 500)이 1% 움직일 때 포트폴리오가 평균적으로 몇 % 움직이는지를 나타내는 민감도 지표입니다. 베타 1.0은 시장과 동일한 움직임, 1.5는 시장보다 50% 더 크게 움직임, 0.5는 시장의 절반만 움직임을 의미합니다. Beta는 위험 선호도에 따라 선택하는 지표로, 높고 낮음이 좋고 나쁨을 의미하지 않습니다.',
                interpretation: {
                    aggressive: '1.0 이상은 시장보다 변동이 큰 공격적 전략입니다.',
                    moderate: '0.5~1.0은 시장과 유사한 적당한 수준입니다.',
                    defensive: '0.5 미만은 시장 대비 안정적인 방어적 전략입니다.'
                },
                formula: 'Cov(포트폴리오, S&P 500) / Var(S&P 500)\n예: 시장 10% 상승 시 포트폴리오 8% 상승 → β = 0.8'
            },
            alpha: {
                title: '알파 (Alpha)',
                description: 'CAPM(자산가격결정모델) 기반으로 계산한 시장 대비 초과 수익률입니다. "시장 위험(베타)만으로 예상되는 수익"을 제외한 순수한 전략의 성과를 측정합니다. 양수일수록 같은 위험 수준에서 시장보다 우수한 성과를 낸 것입니다.',
                interpretation: {
                    high: '3% 이상이면 매우 우수합니다.',
                    medium: '0~3%는 양호합니다.',
                    low: '0% 미만은 시장에 못 미칩니다.'
                },
                formula: '포트폴리오 수익률 - [무위험 수익률 + β × (시장 수익률 - 무위험 수익률)]\n예: 포트폴리오 12%, 시장 10%, β=0.8 → α = 3.6%'
            },
            correlation: {
                title: '상관계수 (Correlation)',
                description: 'S&P 500과의 상관관계를 -1~+1 범위로 나타냅니다. +1은 완전 동조, 0은 무관, -1은 반대 움직임을 의미합니다. 분산 투자 효과를 확인할 수 있습니다.',
                interpretation: {
                    high: '0.8 이상은 시장과 강하게 연동됩니다. 분산 투자 효과가 낮습니다.',
                    medium: '0.3~0.8은 부분적으로 연동됩니다. 적당한 분산 효과가 있습니다.',
                    low: '0.3 미만은 독립적으로 움직입니다. 높은 분산 투자 효과가 있습니다.'
                },
                formula: 'Cov(포트폴리오, S&P 500) / (σ포트폴리오 × σS&P 500)\n예: 포트폴리오와 S&P 500의 피어슨 상관계수'
            },
            informationRatio: {
                title: '정보 비율 (Information Ratio)',
                description: '벤치마크(S&P 500) 대비 초과 수익의 일관성을 측정합니다. 액티브 매니저의 성과를 평가하는 지표로, 높을수록 안정적으로 벤치마크를 초과합니다.',
                interpretation: {
                    high: '0.5 이상이면 우수한 액티브 성과입니다.',
                    medium: '0~0.5는 양호합니다.',
                    low: '0 미만은 벤치마크에 못 미칩니다.'
                },
                formula: '(포트폴리오 수익률 - S&P 500 수익률) / 추적 오차\n추적 오차 = 초과 수익률의 표준편차'
            },
            recoveryPeriod: {
                title: '회복 기간 (Recovery Period)',
                description: '최대 낙폭에서 원래 고점으로 회복하는데 걸린 기간(개월 수)입니다. 포트폴리오의 회복 탄력성을 나타내며, 짧을수록 손실에서 빠르게 회복합니다.',
                interpretation: {
                    high: '3개월 이하면 빠른 회복입니다.',
                    medium: '3~6개월은 보통입니다.',
                    low: '6개월 이상은 회복이 느립니다.'
                },
                formula: 'MDD 발생 후 고점 회복까지의 개월 수\n예: 고점(1월) → 최저점(4월) → 회복(7월) = 6개월'
            },
            maxWinStreak: {
                title: '최대 연속 상승 (Max Win Streak)',
                description: '월 단위로 측정한 연속으로 양의 수익률을 기록한 최대 개월 수입니다. 전략의 상승 지속력을 나타냅니다.',
                interpretation: {
                    high: '10개월 이상이면 안정적입니다.',
                    medium: '5~10개월은 보통입니다.',
                    low: '5개월 미만은 변동성이 큽니다.'
                },
                formula: '연속 양의 월 수익률 기간의 최댓값\n예: 5개월 연속 상승 → 최고 7개월 연속 = 7'
            },
            maxLoseStreak: {
                title: '최대 연속 하락 (Max Loss Streak)',
                description: '월 단위로 측정한 연속으로 음의 수익률을 기록한 최대 개월 수입니다. 전략의 하락 지속 위험을 나타냅니다.',
                interpretation: {
                    high: '3개월 이하면 안정적입니다.',
                    medium: '3~6개월은 보통입니다.',
                    low: '6개월 이상은 위험합니다.'
                },
                formula: '연속 음의 월 수익률 기간의 최댓값\n예: 3개월 연속 하락 → 최고 4개월 연속 = 4'
            },
            avgWinReturn: {
                title: '평균 상승폭 (Average Win Return)',
                description: '월 단위로 측정한 수익이 발생한 개월들의 평균 상승률입니다. 상승장에서 얼마나 크게 오르는지를 나타냅니다.',
                interpretation: {
                    high: '3% 이상이면 우수합니다.',
                    medium: '1~3%는 양호합니다.',
                    low: '1% 미만은 낮습니다.'
                },
                formula: 'Σ(양의 월 수익률) / 양의 개월 수\n예: (+2%, +3%, +1%) → 평균 = 2.0%'
            },
            avgLossReturn: {
                title: '평균 하락폭 (Average Loss Return)',
                description: '월 단위로 측정한 손실이 발생한 개월들의 평균 하락률입니다. 하락장에서 얼마나 떨어지는지를 나타냅니다.',
                interpretation: {
                    high: '-1% 이상이면 안정적입니다.',
                    medium: '-1~-3%는 보통입니다.',
                    low: '-3% 미만은 위험합니다.'
                },
                formula: 'Σ(음의 월 수익률) / 음의 개월 수\n예: (-1%, -2%, -1.5%) → 평균 = -1.5%'
            },
            valueAtRisk95: {
                title: '손실위험도 (VaR 95%)',
                description: '월 단위로 측정한 95% 신뢰수준에서 예상되는 최대 손실입니다. 정상적인 시장 상황에서 월간 최대 손실 예상치를 나타냅니다.',
                interpretation: {
                    high: '-2% 이상이면 안전합니다.',
                    medium: '-2~-5%는 보통입니다.',
                    low: '-5% 미만은 높은 위험입니다.'
                },
                formula: '월별 수익률 분포의 하위 5% 백분위수\n예: 100개월 중 하위 5번째로 나쁜 수익률'
            },
            tailRisk: {
                title: '꼬리 위험 (Tail Risk)',
                description: '월 단위로 측정한 극단적 손실 상황(하위 5%)의 평균 손실률입니다. VaR를 초과하는 최악의 손실들의 평균치로, CVaR 또는 Expected Shortfall이라고도 합니다.',
                interpretation: {
                    high: '-3% 이상이면 안전합니다.',
                    medium: '-3~-7%는 보통입니다.',
                    low: '-7% 미만은 높은 위험입니다.'
                },
                formula: 'VaR를 초과하는 월 손실들의 평균 (CVaR)\n예: 최악의 5개월 손실 (-6%, -7%, -8%, -5%, -9%) → 평균 = -7%'
            }
        };

        // 관리자 관련 변수 추가
        let isAdminLoggedIn = false;
        const ADMIN_PASSWORD = 'assetflow2025'; // 관리자 비밀번호
        let localStrategies = {};
        let localETFData = {};
        // 구글 로그인 관련 변수들
        let googleUser = null;
        let isGoogleLoggedIn = false;
        const GOOGLE_CLIENT_ID = '196649060190-9cc34eohugvmfor7bdj1hm7mksk9fi3l.apps.googleusercontent.com'; // 실제 운영시에는 Google Cloud Console에서 발급받은 클라이언트 ID로 변경
        
        // 앱 상태 관리
        let appState = {
            darkMode: true,
            favorites: [],
            activeOperations: new Set(),
            bestStrategiesCache: {} // 최고 전략 검색 결과 캐시
        };
        
        // 실제 ETF 전략 데이터
        const strategies = {
            all_weather: {
                name: '올웨더 포트폴리오',
                creator: 'Ray Dalio',
                description: '경제 환경에 관계없이 안정적인 수익을 추구하는 전천후 포트폴리오',
                etfs: {
                    'VTI': 30,   // 미국 전체 주식시장
                    'TLT': 40,   // 미국 20년+ 국채
                    'IEF': 15,   // 미국 7-10년 국채
                    'GLD': 7.5,  // 금
                    'DBC': 7.5   // 원자재
                },
                rebalancing: 'quarterly',
                color: '#22C55E',  // 팔레트 1번: 주식
            },
            sixty_forty: {
                name: '60/40 포트폴리오',
                creator: 'Traditional',
                description: '주식 60%, 채권 40%로 구성된 전통적인 균형 포트폴리오',
                etfs: {
                    'VTI': 60,   // 미국 전체 주식시장
                    'BND': 40    // 미국 전체 채권시장
                },
                rebalancing: 'annual',
                color: '#3B82F6',  // 팔레트 2번: 채권
            },
            three_fund: {
                name: '3펀드 포트폴리오',
                creator: 'Bogleheads',
                description: '미국주식, 해외주식, 채권으로 구성된 단순하고 효과적인 포트폴리오',
                etfs: {
                    'VTI': 60,    // 미국 전체 주식시장
                    'VXUS': 20,   // 미국 제외 전세계 주식
                    'BND': 20     // 미국 전체 채권시장
                },
                rebalancing: 'annual',
                color: '#F59E0B',  // 팔레트 3번: 원자재
            },
            golden_butterfly: {
                name: '골든 버터플라이',
                creator: 'Portfolio Charts',
                description: '4개 자산군에 균등 배분하는 안정적인 포트폴리오',
                etfs: {
                    'VTI': 25,   // 미국 주식
                    'TLT': 25,   // 장기 국채
                    'SHY': 25,   // 단기 국채
                    'GLD': 25    // 금
                },
                rebalancing: 'semiannual',
                color: '#8B5CF6',  // 팔레트 4번: 테크/성장주
            },
            ivy_portfolio: {
                name: '아이비 포트폴리오',
                creator: 'Mebane Faber',
                description: '5개 자산군에 균등 배분하는 분산투자 포트폴리오',
                etfs: {
                    'VTI': 20,   // 미국 주식
                    'VEA': 20,   // 선진국 주식
                    'VWO': 20,   // 신흥국 주식
                    'VNQ': 20,   // 부동산
                    'DBC': 20    // 원자재
                },
                rebalancing: 'annual',
                color: '#EF4444',  // 팔레트 5번: 신흥국
            },
            risk_parity: {
                name: '리스크 패리티',
                creator: 'Bridgewater',
                description: '리스크 기여도를 균등하게 배분하는 고급 포트폴리오',
                etfs: {
                    'VTI': 25,
                    'VEA': 25,
                    'TLT': 30,
                    'GLD': 10,
                    'DBC': 10
                },
                rebalancing: 'quarterly',
                color: '#14B8A6',  // 팔레트 6번: 현금/단기채
            }
        };

        // 벤치마크 데이터 (S&P 500)
        const benchmarkData = {
            name: 'S&P 500',
            color: '#F97316'  // 팔레트 7번: 리츠
        };

        // 전역 앱 인스턴스
        let simpleApp;

        function handleGoogleCredentialResponse(response) {
            try {
                const credential = response.credential;
                const payload = JSON.parse(atob(credential.split('.')[1]));
                
                googleUser = {
                    id: payload.sub,
                    name: payload.name,
                    email: payload.email,
                    picture: payload.picture,
                    given_name: payload.given_name,
                    family_name: payload.family_name
                };

                isGoogleLoggedIn = true;
                showUserProfile();
                saveUserSession();
                
                showLoginStatus(`${googleUser.name}님, 환영합니다!`, 'success');
                console.log('구글 로그인 성공:', googleUser);

                setTimeout(() => {
                    closeMenu();
                }, 1500);

            } catch (error) {
                console.error('구글 로그인 응답 처리 오류:', error);
                showLoginStatus('로그인 처리 중 오류가 발생했습니다.', 'error');
            }
        }


        // 구글 로그인 관련 함수들
        function initializeGoogleSignIn() {
            try {
                if (typeof google !== 'undefined' && google.accounts) {
                    google.accounts.id.initialize({
                        client_id: GOOGLE_CLIENT_ID,
                        callback: handleGoogleCredentialResponse,
                        auto_select: false,
                        cancel_on_tap_outside: true
                    });

                    google.accounts.id.disableAutoSelect();
                    console.log('Google Sign-In 초기화 완료');
                } else {
                    console.error('Google Identity Services가 로드되지 않았습니다.');
                    showLoginStatus('Google 로그인 서비스를 불러올 수 없습니다.', 'error');
                }
            } catch (error) {
                console.error('Google Sign-In 초기화 오류:', error);
                showLoginStatus('Google 로그인 초기화 중 오류가 발생했습니다.', 'error');
            }
        }

        function signInWithGoogle() {
            try {
                if (typeof google !== 'undefined' && google.accounts) {
                    const signInBtn = document.getElementById('google-signin-btn');
                    if (signInBtn) {
                        signInBtn.disabled = true;
                        signInBtn.innerHTML = '<div class="loading-spinner small"></div><span>로그인 중...</span>';
                    }

                    google.accounts.id.prompt((notification) => {
                        if (signInBtn) {
                            signInBtn.disabled = false;
                            signInBtn.innerHTML = '<div class="google-icon"></div><span>Google 계정으로 로그인</span>';
                        }

                        if (notification.isNotDisplayed()) {
                            console.log('Google 로그인 프롬프트가 표시되지 않음:', notification.getNotDisplayedReason());
                        }
                    });
                } else {
                    showLoginStatus('Google 로그인 서비스를 사용할 수 없습니다.', 'error');
                }
            } catch (error) {
                console.error('Google 로그인 실행 오류:', error);
                showLoginStatus('로그인 중 오류가 발생했습니다.', 'error');
                
                const signInBtn = document.getElementById('google-signin-btn');
                if (signInBtn) {
                    signInBtn.disabled = false;
                    signInBtn.innerHTML = '<div class="google-icon"></div><span>Google 계정으로 로그인</span>';
                }
            }
        }

        function signOut() {
            try {
                if (typeof google !== 'undefined' && google.accounts) {
                    google.accounts.id.disableAutoSelect();
                }

                const userName = googleUser ? googleUser.name : '사용자';
                
                googleUser = null;
                isGoogleLoggedIn = false;
                hideUserProfile();
                clearUserSession();
                
                showLoginStatus(`${userName}님, 안전하게 로그아웃되었습니다.`, 'success');
                
                console.log('구글 로그아웃 완료');
            } catch (error) {
                console.error('로그아웃 오류:', error);
                showLoginStatus('로그아웃 중 오류가 발생했습니다.', 'error');
            }
        }

        function showUserProfile() {
            if (!googleUser) return;

            const loginPrompt = document.getElementById('login-prompt');
            const userProfile = document.getElementById('user-profile');
            
            if (loginPrompt) loginPrompt.style.display = 'none';
            if (userProfile) userProfile.style.display = 'flex';

            const userAvatar = document.getElementById('user-avatar-img');
            const userName = document.getElementById('user-name');
            const userEmail = document.getElementById('user-email');

            if (userAvatar) userAvatar.src = googleUser.picture || '';
            if (userName) userName.textContent = googleUser.name || '';
            if (userEmail) userEmail.textContent = googleUser.email || '';
        }

        function hideUserProfile() {
            const loginPrompt = document.getElementById('login-prompt');
            const userProfile = document.getElementById('user-profile');
            
            if (loginPrompt) loginPrompt.style.display = 'block';
            if (userProfile) userProfile.style.display = 'none';
        }

        function showLoginStatus(message, type = 'success') {
            const statusElement = document.getElementById('login-status');
            if (!statusElement) return;

            statusElement.textContent = message;
            statusElement.className = `login-status show ${type}`;

            setTimeout(() => {
                statusElement.classList.remove('show');
            }, 3000);
        }

        function saveUserSession() {
            if (googleUser) {
                try {
                    localStorage.setItem('assetflow_google_user', JSON.stringify(googleUser));
                    localStorage.setItem('assetflow_login_time', new Date().toISOString());
                } catch (error) {
                    console.error('사용자 세션 저장 오류:', error);
                }
            }
        }

        function loadUserSession() {
            try {
                const savedUser = localStorage.getItem('assetflow_google_user');
                const loginTime = localStorage.getItem('assetflow_login_time');
                
                if (savedUser && loginTime) {
                    const sessionAge = (new Date() - new Date(loginTime)) / (1000 * 60 * 60);
                    
                    if (sessionAge < 24) {
                        googleUser = JSON.parse(savedUser);
                        isGoogleLoggedIn = true;
                        showUserProfile();
                        console.log('저장된 사용자 세션 로드됨');
                    } else {
                        clearUserSession();
                        console.log('세션이 만료되어 자동 로그아웃됨');
                    }
                }
            } catch (error) {
                console.error('사용자 세션 로드 오류:', error);
                clearUserSession();
            }
        }

        function clearUserSession() {
            localStorage.removeItem('assetflow_google_user');
            localStorage.removeItem('assetflow_login_time');
        }





        // 페이지 로드 시 온보딩 확인 및 이벤트 리스너 설정
        window.addEventListener('load', async function() {
            loadLocalData();           // 새로 추가
            checkAdminStatus();        // 새로 추가
            setupDragAndDrop();        // 새로 추가
            initializeGoogleSignIn();  // 구글 로그인 초기화 추가
            loadUserSession();         // 사용자 세션 로드
            checkAndShowTutorial();    // 첫 방문자 튜토리얼 체크

            // 관리자용 웹페이지

            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('admin') === 'true') {
                setTimeout(() => showAdminLogin(), 500); // 페이지 로드 후 0.5초 뒤에 실행
            }

            // 통화 선택 이벤트 리스너
            const currencySelector = document.getElementById('currency-selector');
            if (currencySelector) {
                currencySelector.addEventListener('change', updateCurrencyDisplay);
                updateCurrencyDisplay();
            }
            
            // 날짜 변경 이벤트 리스너
            const startDateElement = document.getElementById('start-date');
            if (startDateElement) {
                startDateElement.addEventListener('change', function() {
                    validateDateRange();  // 기존 함수 실행
                    validateStartDate(this.value);  // 새 함수 추가
                });
            }

            const endDateElement = document.getElementById('end-date');
            if (endDateElement) {
                endDateElement.addEventListener('change', validateDateRange);
            }
        });

        // 가장 최근 데이터가 있는 월 찾기
        function getLatestDataMonth() {
            let latestDate = null;

            // 모든 ETF 데이터에서 가장 최근 날짜 찾기
            Object.keys(localETFData).forEach(symbol => {
                const data = localETFData[symbol];
                if (data && data.length > 0) {
                    const lastDataDate = new Date(data[data.length - 1].date);
                    if (!latestDate || lastDataDate > latestDate) {
                        latestDate = lastDataDate;
                    }
                }
            });

            if (latestDate) {
                const year = latestDate.getFullYear();
                const month = String(latestDate.getMonth() + 1).padStart(2, '0');
                return `${year}-${month}`;
            }

            // 데이터가 없으면 현재 월 반환
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            return `${year}-${month}`;
        }

        // 로컬 데이터 관리 함수들
        function loadLocalData() {
            try {
                const savedStrategies = localStorage.getItem('assetflow_strategies');
                if (savedStrategies) {
                    localStrategies = JSON.parse(savedStrategies);
                    window.strategies = localStrategies;
                }

                const savedETFData = localStorage.getItem('assetflow_etf_data');
                if (savedETFData) {
                    localETFData = JSON.parse(savedETFData);
                }

                updateDataStatus();

                // 종료 월을 최신 데이터 월로 자동 설정
                updateEndDateToLatest();
            } catch (error) {
                console.error('로컬 데이터 로드 실패:', error);
            }
        }

        // 종료 월을 최신 데이터로 업데이트
        function updateEndDateToLatest() {
            const endDateInput = document.getElementById('end-date');
            if (endDateInput && Object.keys(localETFData).length > 0) {
                const latestMonth = getLatestDataMonth();
                endDateInput.value = latestMonth;
            }
        }

        function saveLocalData() {
            try {
                localStorage.setItem('assetflow_strategies', JSON.stringify(localStrategies));
                localStorage.setItem('assetflow_etf_data', JSON.stringify(localETFData));
                localStorage.setItem('assetflow_last_update', new Date().toISOString());
            } catch (error) {
                console.error('로컬 데이터 저장 실패:', error);
            }
        }

        function checkAdminStatus() {
            const adminStatus = localStorage.getItem('assetflow_admin_session');
            if (adminStatus === 'active') {
                isAdminLoggedIn = true;
                showAdminMenu();
            }
        }

        function showAdminLogin() {
            closeMenu();
            document.getElementById('admin-login-modal').classList.add('active');
            document.getElementById('admin-password').focus();
        }

        function closeAdminLogin() {
            document.getElementById('admin-login-modal').classList.remove('active');
            document.getElementById('admin-password').value = '';
        }

        function confirmAdminLogin() {
            const password = document.getElementById('admin-password').value;
            if (password === ADMIN_PASSWORD) {
                isAdminLoggedIn = true;
                localStorage.setItem('assetflow_admin_session', 'active');
                showAdminMenu();
                closeAdminLogin();
                showNotification('관리자로 로그인되었습니다.', 'success');
            } else {
                showNotification('비밀번호가 올바르지 않습니다.', 'error');
                document.getElementById('admin-password').value = '';
            }
        }

        function showAdminMenu() {
            document.getElementById('admin-menu-section').style.display = 'block';
            document.getElementById('admin-login-section').style.display = 'none';
        }

        function logoutAdmin() {
            isAdminLoggedIn = false;
            localStorage.removeItem('assetflow_admin_session');
            document.getElementById('admin-menu-section').style.display = 'none';
            document.getElementById('admin-login-section').style.display = 'block';
            closeMenu();
            showNotification('관리자에서 로그아웃되었습니다.', 'info');
        }

        function openDataManagement() {
            if (!isAdminLoggedIn) {
                showNotification('관리자 권한이 필요합니다.', 'warning');
                return;
            }
            closeMenu();
            document.getElementById('data-management-modal').classList.add('active');
            updateDataStatus();
        }

        function closeDataManagement() {
            document.getElementById('data-management-modal').classList.remove('active');
        }

        function updateDataStatus() {
            const strategyCount = Object.keys(localStrategies).length;
            const etfDataStatus = Object.keys(localETFData).length > 0 ? '등록됨' : '없음';
            const lastUpdate = localStorage.getItem('assetflow_last_update');
            
            document.getElementById('strategy-count').textContent = strategyCount + '개';
            document.getElementById('etf-data-status').textContent = etfDataStatus;
            document.getElementById('last-update').textContent = lastUpdate ? 
                new Date(lastUpdate).toLocaleString('ko-KR') : '없음';
        }

        function handleUnifiedFile(event) {
            const file = event.target.files[0];
            if (!file) {
                console.log('파일이 선택되지 않음');
                return;
            }
            
            console.log('파일 선택됨:', file.name);
            showNotification('파일을 읽는 중...', 'info');
            
            const reader = new FileReader();
            reader.onerror = function(error) {
                console.error('파일 읽기 오류:', error);
                showNotification('파일 읽기 실패', 'error');
            };
            
            reader.onload = function(e) {
                try {
                    parseUnifiedExcel(e.target.result, file.name);
                } catch (error) {
                    console.error('파일 처리 오류:', error);
                    showNotification('파일 처리 실패: ' + error.message, 'error');
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        function parseUnifiedExcel(arrayBuffer, fileName) {
            // 여기에 디버깅 코드 추가
            console.log('=== parseUnifiedExcel 시작 ===');
            console.log('파일명:', fileName);
            console.log('arrayBuffer 크기:', arrayBuffer.byteLength);
            
            if (typeof XLSX === 'undefined') {
                console.log('❌ XLSX 라이브러리가 없습니다!');
                showNotification('엑셀 처리 라이브러리가 로드되지 않았습니다.', 'error');
                return;
            } else {
                console.log('✅ XLSX 라이브러리 로드됨');
            }

            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            console.log('📋 시트 목록:', workbook.SheetNames);
            let processedSections = 0;
            let newStrategies = {};
            let newETFData = {};

            try {
                // 1. Strategies 시트 처리
                if (workbook.SheetNames.includes('Strategies')) {
                    console.log('Strategies 시트 발견!');
                    const strategiesSheet = workbook.Sheets['Strategies'];
                    const strategiesData = XLSX.utils.sheet_to_json(strategiesSheet, { header: 1 });
                    
                    console.log('전체 데이터:', strategiesData);        // 이 줄 추가
                    console.log('헤더:', strategiesData[0]);            // 이 줄 추가
                    console.log('행 개수:', strategiesData.length);     // 이 줄 추가

                    if (strategiesData.length > 1) {
                        const headers = strategiesData[0];
                        const requiredHeaders = ['id', 'name', 'creator', 'description', 'rebalancing', 'color'];
                        // min_start_date와 data_available_from은 있으면 읽고, 없어도 OK
                        console.log('필요한 헤더:', requiredHeaders);     // 이 줄 추가
                        console.log('실제 헤더:', headers);              // 이 줄 추가
                        console.log('헤더 매칭:', requiredHeaders.every(h => headers.includes(h))); // 이 줄 추가

                        if (requiredHeaders.every(header => headers.includes(header))) {
                            for (let i = 1; i < strategiesData.length; i++) {
                                const row = strategiesData[i];
                                if (!row[0]) continue;
                                
                                const strategyId = row[headers.indexOf('id')];
                                newStrategies[strategyId] = {
                                    name: row[headers.indexOf('name')],
                                    creator: row[headers.indexOf('creator')],
                                    description: row[headers.indexOf('description')],
                                    rebalancing: row[headers.indexOf('rebalancing')],
                                    color: row[headers.indexOf('color')],
                                    minStartDate: row[headers.indexOf('min_start_date')] || null,  // 이 줄 추가
                                    dataAvailableFrom: row[headers.indexOf('data_available_from')] || null,  // 이 줄 추가
                                    etfs: {},
                                    allocation: {}
                                };
                            }
                            processedSections++;
                        } else {
                            showNotification('Strategies 시트에 필수 컬럼이 없습니다.', 'warning');
                        }
                    } else {
                        console.log('Strategies 시트가 없습니다. 시트명:', workbook.SheetNames);
                    }
                }

                // 2. Allocations 시트 처리
                if (workbook.SheetNames.includes('Allocations')) {
                    const allocationsSheet = workbook.Sheets['Allocations'];
                    const allocationsData = XLSX.utils.sheet_to_json(allocationsSheet, { header: 1 });
                    
                    if (allocationsData.length > 1) {
                        const headers = allocationsData[0];
                        const requiredHeaders = ['strategy_id', 'symbol', 'weight'];
                        
                        if (requiredHeaders.every(header => headers.includes(header))) {
                            for (let i = 1; i < allocationsData.length; i++) {
                                const row = allocationsData[i];
                                if (!row[0]) continue;
                                
                                const strategyId = row[headers.indexOf('strategy_id')];
                                const etfSymbol = row[headers.indexOf('symbol')];
                                const weight = parseFloat(row[headers.indexOf('weight')]);
                                
                                if (newStrategies[strategyId]) {
                                    newStrategies[strategyId].etfs[etfSymbol] = weight;
                                    newStrategies[strategyId].allocation[etfSymbol] = weight;
                                }
                            }
                            processedSections++;
                        }
                    }
                }

                // 3. ETF_Data 시트 처리
                if (workbook.SheetNames.includes('ETF_Data')) {
                    const etfSheet = workbook.Sheets['ETF_Data'];
                    const etfData = XLSX.utils.sheet_to_json(etfSheet, { header: 1 });
                    
                    if (etfData.length > 1) {
                        const headers = etfData[0];
                        const requiredHeaders = ['symbol', 'date', 'price'];
                        
                        if (requiredHeaders.every(header => headers.includes(header))) {
                            for (let i = 1; i < etfData.length; i++) {
                                const row = etfData[i];
                                if (!row[0]) continue;
                                
                                const symbol = row[headers.indexOf('symbol')];
                                let date = row[headers.indexOf('date')];
                                const price = parseFloat(row[headers.indexOf('price')]);
                                const volume = row[headers.indexOf('volume')] || 0;
                                
                                // 엑셀 날짜 형식 처리
                                if (typeof date === 'number') {
                                    const utc_days = Math.floor(date - 25569);
                                    const utc_value = utc_days * 86400;
                                    const date_info = new Date(utc_value * 1000);
                                    date = date_info.toISOString().split('T')[0];
                                }
                                
                                if (!newETFData[symbol]) {
                                    newETFData[symbol] = [];
                                }
                                
                                newETFData[symbol].push({
                                    date: date,
                                    price: price,
                                    volume: volume
                                });
                            }
                            
                            // 각 ETF별로 날짜순 정렬
                            Object.keys(newETFData).forEach(symbol => {
                                newETFData[symbol].sort((a, b) => new Date(a.date) - new Date(b.date));
                            });
                            
                            processedSections++;
                        }
                    }
                }

                // 데이터 저장 및 업데이트
                if (processedSections > 0) {
                    if (Object.keys(newStrategies).length > 0) {
                        localStrategies = { ...localStrategies, ...newStrategies };
                        window.strategies = localStrategies;
                    }
                    
                    if (Object.keys(newETFData).length > 0) {
                        localETFData = { ...localETFData, ...newETFData };
                    }

                    saveLocalData();
                    updateDataStatus();

                    // 종료 월을 최신 데이터 월로 자동 업데이트
                    updateEndDateToLatest();
                    
                    const summary = [];
                    if (Object.keys(newStrategies).length > 0) {
                        summary.push(`${Object.keys(newStrategies).length}개 전략`);
                    }
                    if (Object.keys(newETFData).length > 0) {
                        summary.push(`${Object.keys(newETFData).length}개 ETF`);
                    }
                    
                    showNotification(`업로드 완료: ${summary.join(', ')}`, 'success');
                } else {
                    showNotification('처리할 수 있는 데이터가 없습니다. 시트명과 형식을 확인해주세요.', 'warning');
                }

            } catch (error) {
                console.error('통합 파일 파싱 오류:', error);
                showNotification('파일 처리 중 오류가 발생했습니다: ' + error.message, 'error');
            }
        }

        function setupDragAndDrop() {
            const unifiedUpload = document.getElementById('unified-upload-area');
            if (unifiedUpload) {
                unifiedUpload.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.currentTarget.classList.add('dragover');
                });
                unifiedUpload.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.currentTarget.classList.remove('dragover');
                });
                unifiedUpload.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.currentTarget.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        document.getElementById('unified-file-input').files = files;
                        handleUnifiedFile({ target: { files: [files[0]] } });
                    }
                });
            }
        }

        function clearAllData() {
            if (!confirm('모든 데이터를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                return;
            }
            
            localStrategies = {};
            localETFData = {};
            window.strategies = {}; // 기본 전략도 삭제
            
            localStorage.removeItem('assetflow_strategies');
            localStorage.removeItem('assetflow_etf_data');
            localStorage.removeItem('assetflow_last_update');
            
            updateDataStatus();
            showNotification('모든 데이터가 삭제되었습니다.', 'success');
        }

        function exportData() {
            try {
                const exportData = {
                    strategies: localStrategies,
                    etfData: localETFData,
                    exportDate: new Date().toISOString(),
                    version: '1.0.0'
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `assetflow_backup_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);

                showNotification('데이터가 백업 파일로 내보내졌습니다.', 'success');
            } catch (error) {
                console.error('데이터 내보내기 실패:', error);
                showNotification('데이터 내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        function exportToExcel() {
            try {
                if (typeof XLSX === 'undefined') {
                    showNotification('엑셀 처리 라이브러리가 로드되지 않았습니다.', 'error');
                    return;
                }

                // 1. Strategies 시트 데이터 생성
                const strategiesData = [
                    ['id', 'name', 'creator', 'description', 'rebalancing', 'color', 'min_start_date', 'data_available_from']
                ];

                Object.keys(localStrategies).forEach(strategyId => {
                    const strategy = localStrategies[strategyId];
                    strategiesData.push([
                        strategyId,
                        strategy.name || '',
                        strategy.creator || '',
                        strategy.description || '',
                        strategy.rebalancing || '',
                        strategy.color || '',
                        strategy.minStartDate || '',
                        strategy.dataAvailableFrom || ''
                    ]);
                });

                // 2. Allocations 시트 데이터 생성
                const allocationsData = [
                    ['strategy_id', 'symbol', 'weight']
                ];

                Object.keys(localStrategies).forEach(strategyId => {
                    const strategy = localStrategies[strategyId];
                    const allocations = strategy.etfs || strategy.allocation || {};

                    Object.keys(allocations).forEach(symbol => {
                        allocationsData.push([
                            strategyId,
                            symbol,
                            allocations[symbol]
                        ]);
                    });
                });

                // 3. ETF_Data 시트 데이터 생성
                const etfDataRows = [
                    ['symbol', 'date', 'price', 'volume']
                ];

                Object.keys(localETFData).forEach(symbol => {
                    const priceData = localETFData[symbol];

                    if (Array.isArray(priceData)) {
                        priceData.forEach(entry => {
                            etfDataRows.push([
                                symbol,
                                entry.date || '',
                                entry.price || 0,
                                entry.volume || 0
                            ]);
                        });
                    }
                });

                // 워크북 생성
                const workbook = XLSX.utils.book_new();

                // 시트 생성 및 추가
                const strategiesSheet = XLSX.utils.aoa_to_sheet(strategiesData);
                const allocationsSheet = XLSX.utils.aoa_to_sheet(allocationsData);
                const etfDataSheet = XLSX.utils.aoa_to_sheet(etfDataRows);

                XLSX.utils.book_append_sheet(workbook, strategiesSheet, 'Strategies');
                XLSX.utils.book_append_sheet(workbook, allocationsSheet, 'Allocations');
                XLSX.utils.book_append_sheet(workbook, etfDataSheet, 'ETF_Data');

                // 파일 다운로드
                const fileName = `assetflow_data_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(workbook, fileName);

                showNotification('엑셀 파일이 다운로드되었습니다.', 'success');
            } catch (error) {
                console.error('엑셀 내보내기 실패:', error);
                showNotification('엑셀 내보내기 중 오류가 발생했습니다: ' + error.message, 'error');
            }
        }

        function getEffectiveRebalancing(strategy, userChoice) {
            if (userChoice && userChoice !== '') {
                return userChoice; // 사용자 선택이 우선
            }
            return strategy.rebalancing; // 전략 기본값 사용
        }
        
        // 햄버거 메뉴 관리
        function toggleMenu() {
            const menuButton = document.getElementById('menu-button');
            const sideMenu = document.getElementById('side-menu');
            const overlay = document.getElementById('menu-overlay');
            
            menuButton.classList.toggle('active');
            sideMenu.classList.toggle('active');
            overlay.classList.toggle('active');
        }
        
        function closeMenu() {
            const menuButton = document.getElementById('menu-button');
            const sideMenu = document.getElementById('side-menu');
            const overlay = document.getElementById('menu-overlay');
            
            menuButton.classList.remove('active');
            sideMenu.classList.remove('active');
            overlay.classList.remove('active');
        }
        
        // 다크 모드 토글
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            appState.darkMode = isDarkMode;
            const toggle = document.getElementById('dark-mode-toggle');
            const body = document.body;
            
            if (isDarkMode) {
                body.classList.remove('light-mode');
                toggle.classList.add('active');
            } else {
                body.classList.add('light-mode');
                toggle.classList.remove('active');
            }
        }
        
        // 프로필 관련 함수들
        function editProfile() {
            if (isGoogleLoggedIn) {
                showNotification('프로필 편집 기능입니다. 실제 앱에서는 사용자 설정 화면으로 이동합니다.', 'info');
            } else {
                showNotification('프로필 편집 기능을 사용하려면 로그인이 필요합니다.', 'warning');
            }
            closeMenu();
        }
        
        function viewHistory() {
            if (isGoogleLoggedIn) {
                showNotification(`${googleUser.name}님의 분석 기록을 불러오는 중...`, 'info');
            } else {
                showNotification('분석 기록 기능을 사용하려면 로그인이 필요합니다.', 'warning');
            }
            closeMenu();
        }
        
        function manageFavorites() {
            if (isGoogleLoggedIn) {
                showNotification(`${googleUser.name}님의 즐겨찾기 전략을 관리하는 기능입니다.`, 'info');
            } else {
                showNotification('즐겨찾기 기능을 사용하려면 로그인이 필요합니다.', 'warning');
            }
            closeMenu();
        }
        
        // 기타 메뉴 함수들
        function showHelp() {
            showNotification('Then, Follow 사용법: 1. 투자 전략을 선택하세요 2. 백테스트 설정을 조정하세요 3. 결과를 분석하고 비교하세요', 'info', 5000);
            closeMenu();
        }
        
        function showAbout() {
            showNotification('Then, Follow v1.0.0 - 자산배분 백테스트 도구', 'info');
            closeMenu();
        }
        
        function contactSupport() {
            showNotification('문의사항이 있으시면 support@gmail.com으로 연락주세요.', 'info');
            closeMenu();
        }
        
        // 전략 선택 모달 관리
        function openStrategySelector() {
            const modal = document.getElementById('strategy-selector-modal');
            modal.classList.add('active');
            
            // 기본 모드로 복원 (검색 필터 보이게)
            const searchFilter = document.querySelector('.search-filter');
            if (searchFilter) {
                searchFilter.style.display = 'block';
            }
            
            const selectorHeader = document.querySelector('.selector-header h3');
            if (selectorHeader) {
                selectorHeader.textContent = '전략 선택 (복수 선택 가능)';
            }
            
            // 기본 전략 목록 표시
            populateStrategyList();
        }
        
        function closeStrategySelector() {
            const modal = document.getElementById('strategy-selector-modal');
            modal.classList.remove('active');
        }
        
        function populateStrategyList() {
            const listContainer = document.getElementById('strategy-list');
            listContainer.innerHTML = '';

            Object.entries(strategies).forEach(([id, strategy]) => {
                // 간단한 백테스트로 최근 1년 성과 계산
                const preview = calculateStrategyPreview(id);

                const item = document.createElement('div');
                item.className = 'strategy-item';

                // 위험도 뱃지
                let riskBadge = '';
                if (preview) {
                    if (Math.abs(preview.mdd) < 10) {
                        riskBadge = '<span class="risk-badge risk-low">🛡️ 안정적</span>';
                    } else if (Math.abs(preview.mdd) < 20) {
                        riskBadge = '<span class="risk-badge risk-medium">⚖️ 균형형</span>';
                    } else {
                        riskBadge = '<span class="risk-badge risk-high">⚡ 공격적</span>';
                    }
                }

                // 성과 프리뷰 HTML
                const previewHTML = preview ? `
                    <div class="strategy-preview">
                        ${riskBadge}
                        <div class="preview-metric">
                            <span class="preview-label">최근 1년:</span>
                            <span class="preview-value ${preview.return >= 0 ? 'positive' : 'negative'}">
                                ${preview.return >= 0 ? '+' : ''}${preview.return.toFixed(1)}%
                            </span>
                        </div>
                        <div class="preview-metric">
                            <span class="preview-label">최대 낙폭 (MDD):</span>
                            <span class="preview-value negative">${preview.mdd.toFixed(1)}%</span>
                        </div>
                        <div class="preview-metric">
                            <span class="preview-label">변동성 (Volatility):</span>
                            <span class="preview-value">${preview.volatilityLabel}</span>
                        </div>
                    </div>
                ` : '';

                item.innerHTML = `
                    <input type="checkbox" class="strategy-checkbox w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" value="${id}"
                           ${selectedStrategies.includes(id) ? 'checked' : ''}
                           onchange="toggleStrategy('${id}')">
                    <div class="strategy-details">
                        <div class="name">${strategy.name}</div>
                        <div class="creator">${strategy.creator}</div>
                        ${previewHTML}
                    </div>
                `;
                listContainer.appendChild(item);
            });

            updateSelectedCount();
        }

        // 전략 성과 프리뷰 계산 (최근 1년)
        function calculateStrategyPreview(strategyId) {
            // 캐시 확인
            if (strategyPreviewCache.has(strategyId)) {
                return strategyPreviewCache.get(strategyId);
            }

            const strategy = strategies[strategyId];

            // ETF 데이터 확인
            const symbols = Object.keys(strategy.allocation || strategy.etfs || {});
            const hasAllData = symbols.every(symbol => localETFData[symbol] && localETFData[symbol].length > 0);

            if (!hasAllData) {
                strategyPreviewCache.set(strategyId, null);
                return null;
            }

            // 최근 1년 기간 설정
            const endDate = new Date();
            const startDate = new Date();
            startDate.setFullYear(endDate.getFullYear() - 1);

            const startDateStr = startDate.toISOString().split('T')[0];
            const endDateStr = endDate.toISOString().split('T')[0];

            try {
                // 간단한 백테스트 실행
                const performanceData = calculatePortfolioPerformance(
                    strategy,
                    startDateStr,
                    endDateStr,
                    localETFData
                );

                const metrics = calculateMetrics(performanceData, strategy, startDateStr, endDateStr);

                // 변동성 레이블
                let volatilityLabel = '중간';
                if (metrics.volatility < 10) {
                    volatilityLabel = '낮음';
                } else if (metrics.volatility > 20) {
                    volatilityLabel = '높음';
                }

                const preview = {
                    return: metrics.totalReturn,
                    mdd: metrics.maxDrawdown,
                    volatility: metrics.volatility,
                    volatilityLabel: volatilityLabel
                };

                // 캐시 저장
                strategyPreviewCache.set(strategyId, preview);
                return preview;
            } catch (error) {
                console.warn(`전략 ${strategyId} 프리뷰 계산 실패:`, error);
                strategyPreviewCache.set(strategyId, null);
                return null;
            }
        }
        
        function toggleStrategy(strategyId) {
            if (selectedStrategies.includes(strategyId)) {
                selectedStrategies = selectedStrategies.filter(id => id !== strategyId);
            } else {
                selectedStrategies.push(strategyId);
            }
            updateSelectedCount();
            // 선택된 전략 저장
            saveSelectedStrategies();
        }

        // 선택된 전략 저장
        function saveSelectedStrategies() {
            localStorage.setItem('assetflow_selected_strategies', JSON.stringify(selectedStrategies));
        }

        // 선택된 전략 복원
        function loadSelectedStrategies() {
            const saved = localStorage.getItem('assetflow_selected_strategies');
            if (saved) {
                try {
                    selectedStrategies = JSON.parse(saved);
                } catch (error) {
                    console.error('선택된 전략 복원 실패:', error);
                    selectedStrategies = [];
                }
            }
        }
        
        function updateSelectedCount() {
            const countElement = document.getElementById('selected-count');
            countElement.textContent = `${selectedStrategies.length}개 선택됨`;
        }
        
        function filterStrategies() {
            const query = document.getElementById('strategy-search').value.toLowerCase();
            const items = document.querySelectorAll('.strategy-item');
            
            items.forEach(item => {
                const name = item.querySelector('.name').textContent.toLowerCase();
                const creator = item.querySelector('.creator').textContent.toLowerCase();
                
                if (name.includes(query) || creator.includes(query)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }
        
        function confirmStrategySelection() {
            if (selectedStrategies.length > 0) {
                closeStrategySelector();
                updateSearchBoxText();
                
                // 날짜 제한 설정 추가
                setDateLimitsForSelectedStrategies();
                
                showNotification(`${selectedStrategies.length}개 전략이 선택되었습니다.`, 'success');
                
                setTimeout(() => {
                    goToSelection();
                }, 300);
            } else {
                showNotification('최소 1개 전략을 선택해주세요.', 'warning');
            }
        }

        // 새로운 함수 추가 (confirmStrategySelection 바로 아래)
        function setDateLimitsForSelectedStrategies() {
            let latestMinDate = null;
            let limitingStrategy = null;
            
            // 선택된 전략들 중 가장 늦은 시작일 찾기
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                if (strategy.minStartDate) {
                    const minDate = new Date(strategy.minStartDate);
                    if (!latestMinDate || minDate > latestMinDate) {
                        latestMinDate = minDate;
                        limitingStrategy = strategy;
                    }
                }
            });
            
            // 날짜 입력 필드에 제한 설정
            const startDateInput = document.getElementById('start-date');
            if (latestMinDate && startDateInput) {
                const minDateStr = latestMinDate.toISOString().split('T')[0];
                startDateInput.min = minDateStr;
                
                // 현재 설정된 날짜가 최소 날짜보다 이전이면 자동 조정
                if (new Date(startDateInput.value) < latestMinDate) {
                    startDateInput.value = minDateStr;
                }
                
                if (limitingStrategy) {
                    showNotification(
                        `${limitingStrategy.name}는 ${minDateStr} 이후부터 백테스트 가능합니다.`, 
                        'info',
                        4000
                    );
                }
            }
        }
        
        function updateSearchBoxText() {
            const searchInput = document.getElementById('search-input');
            if (selectedStrategies.length === 1) {
                searchInput.value = strategies[selectedStrategies[0]].name;
            } else {
                searchInput.value = `${selectedStrategies.length}개 전략 선택됨`;
            }
        }
        
        // 성과별 최고 전략 찾기 (수정된 버전)
        function findBestStrategies(category) {
            // 중복 실행 방지
            if (appState.activeOperations.has('findBestStrategies')) {
                showNotification('전략 분석이 이미 진행 중입니다.', 'warning');
                return;
            }

            try {
                appState.activeOperations.add('findBestStrategies');

                // 캐시 키 생성 (카테고리 + 날짜)
                const endDate = new Date().toISOString().split('T')[0];
                const cacheKey = `${category}_${endDate}`;

                // 캐시 확인
                if (appState.bestStrategiesCache[cacheKey]) {
                    showNotification('캐시된 결과를 불러오는 중...', 'info', 1000);
                    const cached = appState.bestStrategiesCache[cacheKey];

                    openStrategySelector();
                    setTimeout(() => {
                        showRankedStrategyListWithResults(
                            cached.rankedStrategies,
                            cached.categoryName,
                            cached.sortKey,
                            cached.results
                        );
                        appState.activeOperations.delete('findBestStrategies');
                    }, 100);
                    return;
                }

                showNotification('최고 전략을 분석하는 중... (0%)', 'info', 5000);

                // 자동으로 최근 1년 백테스트 실행
                const startDate = new Date();
                startDate.setFullYear(startDate.getFullYear() - 1);
                const startDateStr = startDate.toISOString().split('T')[0]; // 1년 전

                // 모든 전략에 대해 백테스트 실행
                const allStrategyIds = Object.keys(strategies);
                const tempBacktestResults = {};
                let completed = 0;
                const total = allStrategyIds.length;

                allStrategyIds.forEach(strategyId => {
                    const strategy = strategies[strategyId];

                    try {
                        // 공정한 비교를 위해 모든 전략의 리밸런싱 기간을 분기별(quarterly)로 통일
                        const strategyWithQuarterly = {
                            ...strategy,
                            effectiveRebalancing: 'quarterly'
                        };

                        const performanceData = calculatePortfolioPerformance(
                            strategyWithQuarterly,
                            startDateStr,
                            endDate,
                            localETFData
                        );

                        // performanceData가 객체({values, allocations, rebalanceCount}) 또는 배열일 수 있음
                        const values = performanceData.values || performanceData;
                        if (performanceData && values && values.length > 0) {
                            const metrics = calculateMetrics(performanceData, strategyWithQuarterly, startDateStr, endDate);
                            tempBacktestResults[strategyId] = metrics;
                        }
                    } catch (error) {
                        console.warn(`${strategy.name} 백테스트 실패:`, error);
                        // 실패한 전략은 0으로 처리
                        tempBacktestResults[strategyId] = {
                            totalReturn: 0,
                            maxDrawdown: 0,
                            sharpeRatio: 0,
                            winRate: 0
                        };
                    }

                    // 진행률 업데이트
                    completed++;
                    const progress = Math.round((completed / total) * 100);
                    if (completed % 3 === 0 || completed === total) {
                        showNotification(`최고 전략 분석 중... (${progress}%)`, 'info', 5000);
                    }
                });
                
                // 카테고리별 정렬
                let sortedStrategies = [];
                let categoryName = '';
                let sortKey = '';
                
                switch(category) {
                    case 'total_return':
                        sortedStrategies = Object.entries(strategies)
                            .sort((a, b) => {
                                const aResult = tempBacktestResults[a[0]]?.totalReturn || 0;
                                const bResult = tempBacktestResults[b[0]]?.totalReturn || 0;
                                return bResult - aResult;
                            });
                        categoryName = '최고 수익률 (최근 1년)';
                        sortKey = 'totalReturn';
                        break;
                    case 'low_risk':
                        sortedStrategies = Object.entries(strategies)
                            .sort((a, b) => {
                                const aResult = Math.abs(tempBacktestResults[a[0]]?.maxDrawdown || 0);
                                const bResult = Math.abs(tempBacktestResults[b[0]]?.maxDrawdown || 0);
                                return aResult - bResult;
                            });
                        categoryName = '최저 위험도 (최근 1년)';
                        sortKey = 'mdd';
                        break;
                    case 'sharpe_ratio':
                        sortedStrategies = Object.entries(strategies)
                            .sort((a, b) => {
                                const aResult = tempBacktestResults[a[0]]?.sharpeRatio || 0;
                                const bResult = tempBacktestResults[b[0]]?.sharpeRatio || 0;
                                return bResult - aResult;
                            });
                        categoryName = '최고 샤프비율 (최근 1년)';
                        sortKey = 'sharpeRatio';
                        break;
                    case 'win_rate':
                        sortedStrategies = Object.entries(strategies)
                            .sort((a, b) => {
                                const aResult = tempBacktestResults[a[0]]?.winRate || 0;
                                const bResult = tempBacktestResults[b[0]]?.winRate || 0;
                                return bResult - aResult;
                            });
                        categoryName = '최고 승률 (최근 1년)';
                        sortKey = 'winRate';
                        break;
                    default:
                        throw new Error(`Unknown category: ${category}`);
                }
                
                // 상위 5개만 선택
                const top5Strategies = sortedStrategies.slice(0, 5);

                // 결과 캐싱
                appState.bestStrategiesCache[cacheKey] = {
                    rankedStrategies: top5Strategies,
                    categoryName: categoryName,
                    sortKey: sortKey,
                    results: tempBacktestResults
                };

                showNotification('분석 완료! 결과를 표시합니다.', 'success', 1500);

                // 전략 선택 모달 열기
                openStrategySelector();

                // 모달이 열릴 시간을 줌
                setTimeout(() => {
                    // 임시 백테스트 결과를 사용해서 순위 표시
                    showRankedStrategyListWithResults(top5Strategies, categoryName, sortKey, tempBacktestResults);
                    appState.activeOperations.delete('findBestStrategies');
                }, 100);
                
            } catch (error) {
                console.error('Find best strategies failed:', error);
                showNotification('최고 전략 검색 중 오류가 발생했습니다.', 'error');
                appState.activeOperations.delete('findBestStrategies');
            }
        }

        // 랭킹 리스트 표시 함수 (수정된 버전)
        function showRankedStrategyList(rankedStrategies, categoryName, sortKey) {
            try {
                const listContainer = document.getElementById('strategy-list');
                const selectorHeader = document.querySelector('.selector-header h3');
                
                if (!listContainer || !selectorHeader) {
                    console.error('Required elements not found');
                    return;
                }
                
                // 헤더 제목 변경
                selectorHeader.textContent = `${categoryName} 상위 전략`;
                
                // 검색 필터 숨기기
                const searchFilter = document.querySelector('.search-filter');
                if (searchFilter) {
                    searchFilter.style.display = 'none';
                }
                
                listContainer.innerHTML = '';
                
                rankedStrategies.forEach(([strategyId, strategy], index) => {
                    const ranking = index + 1;
                    const isSelected = selectedStrategies.includes(strategyId);
                    
                    // 해당 카테고리의 실제 수치 가져오기
                    let metricValue, metricUnit;
                    const results = backtestResults[strategyId]; // 실제 백테스트 결과 사용

                    switch(sortKey) {
                        case 'totalReturn':
                            metricValue = results?.totalReturn || 0;
                            metricUnit = '%';
                            break;
                        case 'mdd':
                            metricValue = Math.abs(results?.maxDrawdown || 0);
                            metricUnit = '%';
                            break;
                        case 'sharpeRatio':
                            metricValue = results?.sharpeRatio || 0;
                            metricUnit = '';
                            break;
                        case 'winRate':
                            metricValue = results?.winRate || 0;
                            metricUnit = '%';
                            break;
                        default:
                            metricValue = 0;
                            metricUnit = '';
                    }
                    
                    // 순위별 메달 이모지
                    let rankIcon = '';
                    if (ranking === 1) rankIcon = '🥇';
                    else if (ranking === 2) rankIcon = '🥈';
                    else if (ranking === 3) rankIcon = '🥉';
                    else rankIcon = `${ranking}위`;
                    
                    const item = document.createElement('div');
                    item.className = 'strategy-item ranking-item';
                    if (isSelected) {
                        item.style.background = 'rgba(37, 99, 235, 0.1)';
                        item.style.border = '1px solid #2563EB';
                    }

                    item.innerHTML = `
                        <div style="display: flex; align-items: center; width: 100%;">
                            <div style="margin-right: 12px; font-size: 16px; min-width: 40px;">
                                ${rankIcon}
                            </div>
                            <input type="checkbox" class="strategy-checkbox w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" value="${strategyId}"
                                ${isSelected ? 'checked' : ''}
                                onchange="toggleStrategy('${strategyId}')"
                                style="margin-right: 12px;">
                            <div style="flex: 1;">
                                <div class="strategy-details">
                                    <div class="name" style="font-size: 16px; font-weight: 600; margin-bottom: 2px;">
                                        ${strategy.name}
                                    </div>
                                    <div class="creator" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">
                                        ${strategy.creator}
                                    </div>
                                    <div style="font-size: 13px; color: var(--text-secondary);">
                                        ${strategy.description}
                                    </div>
                                </div>
                            </div>
                            <div style="text-align: right; margin-left: 12px;">
                                <div style="font-size: 18px; font-weight: 700; color: var(--color-primary);">
                                    ${sortKey === 'sharpeRatio' ? metricValue.toFixed(2) : Math.round(metricValue)}${metricUnit}
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    ${getCategoryDisplayName(sortKey)}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    listContainer.appendChild(item);
                });
                
                updateSelectedCount();
                
            } catch (error) {
                console.error('Ranked strategy list display failed:', error);
                showNotification('랭킹 리스트 표시 중 오류가 발생했습니다.', 'error');
            }
        }

        function showRankedStrategyListWithResults(rankedStrategies, categoryName, sortKey, results) {
            // 기존 showRankedStrategyList와 비슷하지만 results 파라미터에서 성과 데이터 가져옴
            const listContainer = document.getElementById('strategy-list');
            const selectorHeader = document.querySelector('.selector-header h3');
            
            selectorHeader.textContent = categoryName;
            
            const searchFilter = document.querySelector('.search-filter');
            if (searchFilter) {
                searchFilter.style.display = 'none';
            }
            
            listContainer.innerHTML = '';
            
            rankedStrategies.forEach(([strategyId, strategy], index) => {
                const ranking = index + 1;
                const isSelected = selectedStrategies.includes(strategyId);
                
                let metricValue, metricUnit;
                const metrics = results[strategyId];
                
                switch(sortKey) {
                    case 'totalReturn':
                        metricValue = metrics?.totalReturn || 0;
                        metricUnit = '%';
                        break;
                    case 'mdd':
                        metricValue = Math.abs(metrics?.maxDrawdown || 0);
                        metricUnit = '%';
                        break;
                    case 'sharpeRatio':
                        metricValue = metrics?.sharpeRatio || 0;
                        metricUnit = '';
                        break;
                    case 'winRate':
                        metricValue = metrics?.winRate || 0;
                        metricUnit = '%';
                        break;
                    default:
                        metricValue = 0;
                        metricUnit = '';
                }
                
                let rankIcon = '';
                if (ranking === 1) rankIcon = '🥇';
                else if (ranking === 2) rankIcon = '🥈';
                else if (ranking === 3) rankIcon = '🥉';
                else rankIcon = `${ranking}위`;
                
                const item = document.createElement('div');
                item.className = 'strategy-item ranking-item';
                if (isSelected) {
                    item.style.background = 'rgba(37, 99, 235, 0.1)';
                    item.style.border = '1px solid #2563EB';
                }

                item.innerHTML = `
                    <div style="display: flex; align-items: center; width: 100%;">
                        <div style="margin-right: 12px; font-size: 16px; min-width: 40px;">
                            ${rankIcon}
                        </div>
                        <input type="checkbox" class="strategy-checkbox w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600" value="${strategyId}"
                            ${isSelected ? 'checked' : ''}
                            onchange="toggleStrategy('${strategyId}')"
                            style="margin-right: 12px;">
                        <div style="flex: 1;">
                            <div class="strategy-details">
                                <div class="name" style="font-size: 16px; font-weight: 600; margin-bottom: 2px;">
                                    ${strategy.name}
                                </div>
                                <div class="creator" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">
                                    ${strategy.creator}
                                </div>
                                <div style="font-size: 13px; color: var(--text-secondary);">
                                    ${strategy.description}
                                </div>
                            </div>
                        </div>
                        <div style="text-align: right; margin-left: 12px;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--color-primary);">
                                ${metricValue.toFixed(sortKey === 'sharpeRatio' ? 2 : 1)}${metricUnit}
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary);">
                                ${getCategoryDisplayName(sortKey)}
                            </div>
                        </div>
                    </div>
                `;
                
                listContainer.appendChild(item);
            });
            
            updateSelectedCount();
        }

        // 카테고리 표시명 반환
        function getCategoryDisplayName(sortKey) {
            const displayNames = {
                'totalReturn': '총수익률',
                'mdd': '최대낙폭',
                'sharpeRatio': '샤프비율',
                'winRate': '승률'
            };
            return displayNames[sortKey] || sortKey;
        }

        // 화면 전환
        function goToHome() {
            document.getElementById('home-screen').style.display = 'flex';
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('analysis-screen').style.display = 'none';
            // 현재 화면 상태 저장
            localStorage.setItem('assetflow_current_screen', 'home');
        }

        function goToSelection() {
            document.getElementById('home-screen').style.display = 'none';
            document.getElementById('selection-screen').style.display = 'block';
            document.getElementById('analysis-screen').style.display = 'none';
            updateSelectionScreen();
            // 현재 화면 상태 저장
            localStorage.setItem('assetflow_current_screen', 'selection');
        }

        function goToAnalysis() {
            document.getElementById('home-screen').style.display = 'none';
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('analysis-screen').style.display = 'block';

            // 날짜 범위 힌트 업데이트
            updateDateRangeInfo();
            // 현재 화면 상태 저장
            localStorage.setItem('assetflow_current_screen', 'analysis');
        }

        // 빠른 날짜 선택 함수 (월 형식)
        function setQuickDate(years, event) {
            const today = new Date();
            const endYear = today.getFullYear();
            const endMonth = String(today.getMonth() + 1).padStart(2, '0');
            const endDate = `${endYear}-${endMonth}`;

            const startDate = new Date(today);
            startDate.setFullYear(today.getFullYear() - years);
            const startYear = startDate.getFullYear();
            const startMonth = String(startDate.getMonth() + 1).padStart(2, '0');
            const startDateStr = `${startYear}-${startMonth}`;

            document.getElementById('start-date').value = startDateStr;
            document.getElementById('end-date').value = endDate;

            // 날짜 범위 정보 업데이트
            updateDateRangeInfo();

            // 피드백 애니메이션
            if (event && event.target) {
                const buttons = document.querySelectorAll('.quick-date-btn');
                buttons.forEach(btn => {
                    btn.style.background = '';
                    btn.style.color = '';
                });
                event.target.style.background = 'var(--color-primary)';
                event.target.style.color = 'white';

                setTimeout(() => {
                    event.target.style.background = '';
                    event.target.style.color = '';
                }, 1000);
            }
        }

        // 날짜 범위 정보 업데이트 함수
        function updateDateRangeInfo() {
            const startMonth = document.getElementById('start-date').value;
            const endMonth = document.getElementById('end-date').value;
            const infoBox = document.getElementById('date-range-info');
            const message = document.getElementById('date-range-message');

            if (!startMonth || !endMonth) return;

            // 월을 마지막 영업일 날짜로 변환
            const startDate = convertMonthToLastTradingDay(startMonth);
            const endDate = convertMonthToLastTradingDay(endMonth);

            // 날짜 범위 계산
            const start = new Date(startDate);
            const end = new Date(endDate);
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            const diffYears = (diffDays / 365).toFixed(1);
            const diffMonths = Math.round(diffDays / 30);

            // 선택된 전략의 데이터 가용성 확인
            let dataAvailable = true;
            let limitingETF = null;
            let earliestDate = null;

            if (selectedStrategies.length > 0) {
                selectedStrategies.forEach(strategyId => {
                    const strategy = strategies[strategyId];
                    const symbols = Object.keys(strategy.allocation || strategy.etfs || {});

                    symbols.forEach(symbol => {
                        if (localETFData[symbol] && localETFData[symbol].length > 0) {
                            const firstDate = new Date(localETFData[symbol][0].date);
                            if (firstDate > start) {
                                dataAvailable = false;
                                if (!earliestDate || firstDate < earliestDate) {
                                    earliestDate = firstDate;
                                    limitingETF = symbol;
                                }
                            }
                        }
                    });
                });
            }

            // 메시지 생성
            if (!dataAvailable && earliestDate) {
                infoBox.style.display = 'block';
                infoBox.style.background = 'var(--bg-danger-alpha)';
                infoBox.style.borderColor = 'var(--color-danger)';
                message.innerHTML = `⚠️ <strong>${limitingETF}</strong> 데이터는 <strong>${earliestDate.toISOString().split('T')[0]}</strong>부터 사용 가능합니다. 시작일을 조정해주세요.`;
            } else if (diffDays < 365) {
                infoBox.style.display = 'block';
                infoBox.style.background = 'var(--bg-warning-alpha)';
                infoBox.style.borderColor = 'var(--color-warning)';
                message.innerHTML = `⚠️ 선택한 기간이 <strong>${diffMonths}개월</strong>로 짧습니다. 신뢰할 수 있는 결과를 위해 최소 1년 이상을 권장합니다.`;
            } else {
                infoBox.style.display = 'block';
                infoBox.style.background = 'var(--bg-success-alpha)';
                infoBox.style.borderColor = 'var(--color-success)';
                message.innerHTML = `✅ 백테스트 기간: <strong>${diffYears}년</strong> (약 ${diffMonths}개월)`;
            }
        }

        // 날짜 입력 시 정보 업데이트

        // 페이지 로드 시 다크모드 초기화
        document.addEventListener('DOMContentLoaded', function() {
            const html = document.documentElement;
            if (!document.body.classList.contains('light-mode')) {
                html.classList.add('dark');
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');

            if (startDateInput) {
                startDateInput.addEventListener('change', updateDateRangeInfo);
            }
            if (endDateInput) {
                endDateInput.addEventListener('change', updateDateRangeInfo);
            }

            // 페이지 새로고침 시 이전 화면 상태 복원
            restoreScreenState();
        });

        // 화면 상태 복원 함수
        function restoreScreenState() {
            // 먼저 선택된 전략을 복원
            loadSelectedStrategies();

            // sessionStorage로 첫 방문과 새로고침 구분
            const isSessionActive = sessionStorage.getItem('assetflow_session_active');

            if (!isSessionActive) {
                // 처음 파일을 열었을 때 → 항상 홈 화면으로
                sessionStorage.setItem('assetflow_session_active', 'true');
                goToHome();
            } else {
                // 새로고침인 경우 → 이전 화면 상태 복원
                const savedScreen = localStorage.getItem('assetflow_current_screen');

                if (!savedScreen || savedScreen === 'home') {
                    // 저장된 상태가 없거나 홈 화면이면 홈으로 (기본값)
                    goToHome();
                } else if (savedScreen === 'selection') {
                    // 전략 선택 화면이었으면 복원
                    if (selectedStrategies.length > 0) {
                        goToSelection();
                    } else {
                        // 선택된 전략이 없으면 홈으로
                        goToHome();
                    }
                } else if (savedScreen === 'analysis') {
                    // 분석 화면이었으면 복원
                    if (selectedStrategies.length > 0) {
                        goToAnalysis();
                        // 백테스트를 다시 실행하고 차트 재생성
                        setTimeout(() => {
                            runBacktest();
                        }, 100);
                    } else {
                        // 선택된 전략이 없으면 홈으로
                        goToHome();
                    }
                }
            }
        }
        
        function updateSelectionScreen() {
            const container = document.getElementById('selected-strategies');
            container.innerHTML = '';
            
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const card = document.createElement('div');
                card.className = 'selected-strategy-card fade-in bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow hover:shadow-lg transition-all duration-300';
                
                // 백테스트 가능 기간 정보 추가
                let availabilityInfo = '';
                if (strategy.minStartDate) {
                    availabilityInfo = `
                        <div class="data-availability" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-subtle); font-size: 13px; color: var(--text-secondary);">
                            📅 백테스트 가능: ${strategy.minStartDate} 이후
                            ${strategy.dataAvailableFrom ? `<br><span style="font-size: 11px;">(${strategy.dataAvailableFrom} 기준)</span>` : ''}
                        </div>
                    `;
                }
                
                card.innerHTML = `
                    <button class="remove-btn" onclick="removeStrategy('${strategyId}')">×</button>
                    <div class="strategy-info">
                        <h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">${strategy.name}</h3>
                        <div class="creator">${strategy.creator}</div>
                        <div class="description">${strategy.description}</div>
                        ${availabilityInfo}
                    </div>
                `;
                container.appendChild(card);
            });
            
            document.getElementById('compare-btn').disabled = selectedStrategies.length === 0;
        }
        
        function removeStrategy(strategyId) {
            selectedStrategies = selectedStrategies.filter(id => id !== strategyId);
            updateSelectionScreen();
            // 선택된 전략 저장
            saveSelectedStrategies();
        }

        function validateETFData() {
            const missingData = [];
            const requiredETFs = new Set();
            
            // 선택된 전략들의 모든 ETF 수집
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const symbols = Object.keys(strategy.allocation || strategy.etfs || {});
                symbols.forEach(symbol => requiredETFs.add(symbol));
            });
            
            // SPY(벤치마크)도 필수
            requiredETFs.add('SPY');
            
            // 데이터 존재 확인
            Array.from(requiredETFs).forEach(symbol => {
                if (!localETFData[symbol] || localETFData[symbol].length === 0) {
                    missingData.push(symbol);
                }
            });
            
            return {
                isValid: missingData.length === 0,
                missingData
            };
        }

        // ETF 데이터 품질 검증
        function validateETFDataQuality(symbol, startDate, endDate) {
            // 데이터 존재 여부 확인
            if (!localETFData[symbol] || localETFData[symbol].length === 0) {
                return {
                    valid: false,
                    reason: '데이터가 없습니다',
                    suggestion: `${symbol} ETF 데이터를 업로드해주세요`
                };
            }

            const data = localETFData[symbol];
            const firstDataDate = new Date(data[0].date);
            const lastDataDate = new Date(data[data.length - 1].date);
            const requestedStart = new Date(startDate);
            const requestedEnd = new Date(endDate);

            // 시작 날짜 확인
            if (requestedStart < firstDataDate) {
                return {
                    valid: false,
                    reason: '시작일 이전 데이터가 없습니다',
                    suggestion: `${symbol}의 데이터는 ${data[0].date}부터 시작합니다`
                };
            }

            // 종료 날짜 확인
            if (requestedEnd > lastDataDate) {
                return {
                    valid: false,
                    reason: '종료일 이후 데이터가 없습니다',
                    suggestion: `${symbol}의 데이터는 ${data[data.length - 1].date}까지만 있습니다`
                };
            }

            // 데이터 간격 확인 (월별 데이터가 충분한지)
            const monthsBetween = (requestedEnd.getFullYear() - requestedStart.getFullYear()) * 12 +
                                  (requestedEnd.getMonth() - requestedStart.getMonth());

            if (data.length < monthsBetween * 0.8) {
                return {
                    valid: false,
                    reason: '데이터가 불완전합니다',
                    suggestion: `${symbol}의 데이터에 누락된 월이 많습니다`
                };
            }

            return { valid: true };
        }

        async function runBacktest() {
            if (selectedStrategies.length === 0) {
                showNotification('분석할 전략을 먼저 선택해주세요.', 'warning');
                return;
            }

            // 월 입력을 마지막 영업일 날짜로 변환
            let userStartDate = convertMonthToLastTradingDay(document.getElementById('start-date').value);
            const endDate = convertMonthToLastTradingDay(document.getElementById('end-date').value);

            // 데이터 품질 검증
            const validationErrors = [];
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const symbols = Object.keys(strategy.allocation || strategy.etfs || {});

                symbols.forEach(symbol => {
                    const validation = validateETFDataQuality(symbol, userStartDate, endDate);
                    if (!validation.valid) {
                        validationErrors.push(`${symbol}: ${validation.reason}`);
                        if (validation.suggestion) {
                            validationErrors.push(`  → ${validation.suggestion}`);
                        }
                    }
                });
            });

            if (validationErrors.length > 0) {
                showNotification(
                    '데이터 품질 문제:\n' + validationErrors.slice(0, 3).join('\n'),
                    'warning',
                    5000
                );
            }
            const userRebalancing = document.getElementById('user-rebalancing-override').value;
            
            // 선택된 전략들의 가장 늦은 시작일 찾기
            let latestStartDate = new Date(userStartDate);
            let limitingStrategy = null;
            
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const symbols = Object.keys(strategy.allocation || strategy.etfs || {});
                
                symbols.forEach(symbol => {
                    if (localETFData[symbol] && localETFData[symbol].length > 0) {
                        const firstDataDate = new Date(localETFData[symbol][0].date);
                        if (firstDataDate > latestStartDate) {
                            latestStartDate = firstDataDate;
                            limitingStrategy = strategy;
                        }
                    }
                });
            });
            
            // 자동 조정된 시작일 적용
            const finalStartDate = latestStartDate.toISOString().split('T')[0];
            
            // 시작일이 조정되었으면 알림
            if (finalStartDate !== userStartDate) {
            console.log('날짜 조정됨:', userStartDate, '->', finalStartDate); // 디버그용
            console.log('제한 전략:', limitingStrategy); // 디버그용
            
            document.getElementById('start-date').value = finalStartDate;
            
            const year = latestStartDate.getFullYear();
            const month = latestStartDate.getMonth() + 1;
            
            const message = `${limitingStrategy.name}의 마지막 ETF 상장일인 ${year}년 ${month}월부터로 백테스트 시작일이 변경됩니다.`;
            
            console.log('알림 메시지:', message); // 디버그용
            
            showNotification(message, 'info', 5000);
        }
            
            const resultsCard = document.getElementById('results-card');
            resultsCard.style.display = 'block';
            resultsCard.scrollIntoView({ behavior: 'smooth' });

            setButtonLoading('run-backtest-btn', true);
            showProgressBar(true);
            showLoading('chart-loading', true);

            try {
                // ETF 데이터 필수 검증
                const validation = validateETFData();
                if (!validation.isValid) {
                    showNotification(`백테스트 불가: ${validation.missingData.join(', ')}`, 'error');
                    return;
                }

                updateProgress(30, '백테스트 실행 중...');
                
                // 실제 백테스트만 실행
                executeRealBacktest();
                
                updateProgress(100, '완료!');
                document.getElementById('chart-content').style.display = 'block';
                showNotification('백테스트가 완료되었습니다!', 'success');
                
            } catch (error) {
                console.error('백테스트 실행 오류:', error);
                showNotification('백테스트 실행 중 오류: ' + error.message, 'error');
            } finally {
                setButtonLoading('run-backtest-btn', false);
                showProgressBar(false);
                showLoading('chart-loading', false);
            }
        }

        function executeRealBacktest() {
            const totalStrategies = selectedStrategies.length;
            let completedStrategies = 0;

            updateProgress(10, `백테스트 준비 중... (0/${totalStrategies} 전략)`);

            selectedStrategies.forEach((strategyId, index) => {
                setTimeout(() => {
                    const strategy = strategies[strategyId];
                    const startDate = document.getElementById('start-date').value;
                    const endDate = document.getElementById('end-date').value;

                    updateProgress(
                        10 + (index / totalStrategies) * 70,
                        `${strategy.name} 분석 중... (${index + 1}/${totalStrategies})`
                    );

                    const performanceData = calculatePortfolioPerformance(
                        strategy,
                        startDate,
                        endDate,
                        localETFData
                    );

                    portfolioTimeSeries[strategyId] = performanceData;
                    backtestResults[strategyId] = calculateMetrics(performanceData, strategy, startDate, endDate);

                    completedStrategies++;

                    if (completedStrategies === totalStrategies) {
                        updateProgress(80, '차트 생성 중...');

                        setTimeout(() => {
                            createComparisonChart();
                            generateRealDetailedMetrics();
                            // generateYearlyPerformanceTable(); // 함수가 정의되지 않음 - yearly 탭 열 때 자동 생성됨

                            updateProgress(100, '완료!');
                        }, 300);
                    }
                }, index * 200);
            });
        }

        function executeRealBacktest_old() {
            const progressSteps = [
                { percent: 20, text: '데이터 수집 중...', delay: 100 },
                { percent: 40, text: '전략 분석 중...', delay: 200 },
                { percent: 60, text: '성과 계산 중...', delay: 300 },
                { percent: 80, text: '차트 생성 중...', delay: 200 },
                { percent: 100, text: '완료!', delay: 100 }
            ];

            let currentStep = 0;

            function executeNextStep() {
                if (currentStep < progressSteps.length) {
                    const step = progressSteps[currentStep];
                    updateProgress(step.percent, step.text);
                    currentStep++;
                    
                    setTimeout(() => {
                        executeNextStep();
                    }, step.delay);
                } else {
                    setTimeout(() => {
                        completeRealBacktest();
                    }, 100);
                }
            }
            
            executeNextStep();
        }
        
        function completeRealBacktest() {
            try {
                const startDate = document.getElementById('start-date').value;
                const endDate = document.getElementById('end-date').value;
                
                selectedStrategies.forEach(strategyId => {
                    const strategy = strategies[strategyId];
                    
                    console.log(`${strategy.name} 백테스트 시작...`);
                    
                    const performanceData = calculatePortfolioPerformance(
                        strategy, 
                        startDate, 
                        endDate, 
                        localETFData
                    );
                    
                    if (!performanceData || performanceData.length === 0) {
                        throw new Error(`${strategy.name} 성과 계산 실패`);
                    }
                    
                    const metrics = calculateMetrics(performanceData, strategy, startDate, endDate);
                    
                    backtestResults[strategyId] = metrics;
                    portfolioTimeSeries[strategyId] = performanceData;
                    
                    console.log(`${strategy.name} 백테스트 완료:`, metrics);
                });
                
                // 로딩 상태 종료
                setButtonLoading('run-backtest-btn', false);
                showProgressBar(false);
                showLoading('chart-loading', false);
                
                // 차트 생성 (실제 데이터 사용)
                createComparisonChart();
                
                // 모든 분석 데이터 생성 (실제 데이터 사용)
                generateAllRealAnalysisData();
                
                // 결과 표시
                document.getElementById('chart-content').style.display = 'block';
                
                showNotification('백테스트가 완료되었습니다!', 'success');
            } catch (error) {
                setButtonLoading('run-backtest-btn', false);
                showProgressBar(false);
                showLoading('chart-loading', false);
                
                showNotification('백테스트 처리 중 오류가 발생했습니다: ' + error.message, 'error');
                console.error('Backtest completion error:', error);
            }
        }
        
        // 날짜 유효성 검사 함수
        function validateDateRange() {
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');

            if (!startDateInput || !endDateInput) return;

            // 월을 마지막 영업일 날짜로 변환
            const startDate = convertMonthToLastTradingDay(startDateInput.value);
            const endDate = convertMonthToLastTradingDay(endDateInput.value);

            const start = new Date(startDate);
            const end = new Date(endDate);
            const today = new Date();

            // 시작일이 종료일보다 늦은 경우
            if (start >= end) {
                showNotification('시작 월은 종료 월보다 빨라야 합니다.', 'warning');
                // 종료월을 시작월 + 1년으로 자동 조정
                const newEndDate = new Date(start);
                newEndDate.setFullYear(start.getFullYear() + 1);
                const newEndYear = newEndDate.getFullYear();
                const newEndMonth = String(newEndDate.getMonth() + 1).padStart(2, '0');
                endDateInput.value = `${newEndYear}-${newEndMonth}`;
                return;
            }

            // 시작일이 너무 미래인 경우
            if (start > today) {
                showNotification('시작 월은 오늘 이전이어야 합니다.', 'warning');
                startDateInput.value = '2020-01';
                return;
            }

            // 종료일이 너무 미래인 경우
            if (end > today) {
                showNotification('종료 월은 오늘 이전이어야 합니다.', 'warning');
                const currentYear = today.getFullYear();
                const currentMonth = String(today.getMonth() + 1).padStart(2, '0');
                endDateInput.value = `${currentYear}-${currentMonth}`;
                return;
            }
            
            // 기간이 너무 짧은 경우 (1년 미만)
            const daysDiff = (end - start) / (1000 * 60 * 60 * 24);
            if (daysDiff < 365) {
                showNotification('백테스트 기간은 최소 1년 이상이어야 합니다.', 'warning');
                return;
            }
            
            // 유효한 날짜 범위인 경우
            if (daysDiff >= 365) {
                const years = (daysDiff / 365).toFixed(2);
                showNotification(`백테스트 기간: ${years}년이 설정되었습니다.`, 'success', 2000);
            }
        }


        function validateStartDate(selectedDate) {
            if (selectedStrategies.length === 0) return;
            
            let latestRequiredDate = new Date(selectedDate);
            let limitingStrategy = null;
            
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const symbols = Object.keys(strategy.allocation || strategy.etfs || {});
                
                symbols.forEach(symbol => {
                    if (localETFData[symbol] && localETFData[symbol].length > 0) {
                        const firstDataDate = new Date(localETFData[symbol][0].date);
                        if (firstDataDate > latestRequiredDate) {
                            latestRequiredDate = firstDataDate;
                            limitingStrategy = strategy;
                        }
                    }
                });
            });
            
            if (limitingStrategy && new Date(selectedDate) < latestRequiredDate) {
                const year = latestRequiredDate.getFullYear();
                const month = latestRequiredDate.getMonth() + 1;
                const adjustedDate = latestRequiredDate.toISOString().split('T')[0];
                
                document.getElementById('start-date').value = adjustedDate;
                
                showNotification(
                    `${limitingStrategy.name}의 ETF 상장일로 인해 ${year}년 ${month}월부터 백테스트가 가능합니다.`,
                    'warning',
                    4000
                );
            }
        }

        
        function formatMetricValue(value, format) {
            if (value === undefined || value === null || isNaN(value)) {
                return '-';
            }

            switch(format) {
                case '%': return (value >= 0 ? '+' : '') + value.toFixed(1) + '%';
                case 'ratio': return value.toFixed(2);
                case 'days': return Math.floor(value) + '일';
                case 'months': return Math.floor(value) + '개월';
                case 'count': return Math.floor(value) + '회';
                default: return value.toFixed(2);
            }
        }
        
        function getMetricColorClass(value, type) {
            if (type === 'positive') return value > 0 ? 'positive' : 'negative';
            if (type === 'negative') return value < 0 ? 'negative' : 'positive';
            return 'neutral';
        }
        
        function getCorrelationColor(correlation) {
            // 1.00과 -1.00은 진하게, 나머지는 아주 연하게
            if (correlation >= 0.999) {
                // 1.00: 진한 파란색
                return `rgba(49, 130, 246, 1.0)`;
            } else if (correlation > 0) {
                // 나머지 양수: 아주 연한 파란색
                return `rgba(49, 130, 246, 0.15)`;
            } else if (correlation <= -0.999) {
                // -1.00: 진한 빨간색
                return `rgba(239, 68, 68, 1.0)`;
            } else {
                // 나머지 음수: 아주 연한 빨간색
                return `rgba(239, 68, 68, 0.15)`;
            }
        }
        
        // ===== 백테스트 엔진 구현 =====

        // ETF 데이터에서 특정 날짜의 가격 가져오기
        function getETFPrice(symbol, date, etfData) {
            if (!etfData[symbol] || etfData[symbol].length === 0) {
                console.warn(`${symbol} ETF 데이터 없음`);
                return null;
            }
            
            const targetDate = new Date(date);
            targetDate.setHours(0, 0, 0, 0); // Normalize to start of day
            
            let closestData = null;
            let minDiff = Infinity;
            
            // Find closest date (prefer previous dates, but accept future if needed)
            for (const data of etfData[symbol]) {
                const dataDate = new Date(data.date);
                dataDate.setHours(0, 0, 0, 0);
                
                const diff = Math.abs(targetDate - dataDate);
                
                // Within 30 days (more realistic for monthly data)
                if (diff <= 30 * 24 * 60 * 60 * 1000 && diff < minDiff) {
                    minDiff = diff;
                    closestData = data;
                }
            }
            
            if (!closestData) {
                console.warn(`${symbol} - ${targetDate.toISOString().split('T')[0]} 근처 가격 없음 (30일 범위)`);
                // Fallback: return first available data point
                return etfData[symbol][0]?.price || null;
            }
            
            return closestData.price;
        }

        // 월 입력(YYYY-MM)을 해당 월의 마지막 영업일 날짜(YYYY-MM-DD)로 변환
        function convertMonthToLastTradingDay(yearMonth) {
            if (!yearMonth) return null;

            // yearMonth가 이미 YYYY-MM-DD 형식이면 그대로 반환
            if (yearMonth.length === 10 && yearMonth.split('-').length === 3) {
                return yearMonth;
            }

            const [year, month] = yearMonth.split('-');
            const monthInt = parseInt(month);

            // 해당 월의 마지막 날 계산
            const lastDayOfMonth = new Date(year, monthInt, 0);
            const endOfMonth = new Date(year, monthInt - 1, lastDayOfMonth.getDate());

            // SPY 데이터에서 해당 월의 마지막 영업일 찾기
            if (localETFData['SPY'] && localETFData['SPY'].length > 0) {
                const monthStart = new Date(year, monthInt - 1, 1);
                const monthEnd = new Date(year, monthInt, 0, 23, 59, 59);

                // 해당 월의 모든 데이터 필터링
                const monthData = localETFData['SPY'].filter(d => {
                    const date = new Date(d.date);
                    return date >= monthStart && date <= monthEnd;
                });

                if (monthData.length > 0) {
                    // 마지막 영업일 반환
                    const lastTradingDay = monthData[monthData.length - 1].date;
                    return lastTradingDay;
                }
            }

            // 데이터가 없으면 해당 월의 마지막 날 반환
            return endOfMonth.toISOString().split('T')[0];
        }

        // 날짜 범위 생성 (월별)
        function generateDateRange(startDate, endDate) {
            const dates = [];
            const current = new Date(startDate);
            const end = new Date(endDate);
            
            while (current <= end) {
                dates.push(new Date(current));
                current.setMonth(current.getMonth() + 1);
            }
            
            return dates;
        }

        // 리밸런싱 필요 여부 확인
        function needsRebalancing(currentAllocation, targetAllocation, threshold = 0.05) {
            for (const symbol in targetAllocation) {
                const currentWeight = currentAllocation[symbol] || 0;
                const targetWeight = targetAllocation[symbol];
                
                if (Math.abs(currentWeight - targetWeight) > threshold * targetWeight) {
                    return true;
                }
            }
            return false;
        }

        // 리밸런싱 주기 확인
        function shouldRebalance(date, lastRebalanceDate, period) {
            if (!lastRebalanceDate) return true;
            
            // none인 경우 리밸런싱 안 함
            if (period === 'none') return false;
            
            const monthsDiff = (date.getFullYear() - lastRebalanceDate.getFullYear()) * 12 
                            + (date.getMonth() - lastRebalanceDate.getMonth());
            
            switch(period) {
                case 'monthly': return monthsDiff >= 1;
                case 'quarterly': return monthsDiff >= 3;
                case 'semiannual': return monthsDiff >= 6;
                case 'annual': return monthsDiff >= 12;
                case 'none': return false;
                default: return monthsDiff >= 3; // 기본값: 분기별
            }
        }

        function calculatePortfolioPerformance(strategy, startDate, endDate, etfData) {
            const allocation = strategy.allocation || strategy.etfs;
            const userRebalancing = document.getElementById('user-rebalancing-override')?.value;
            const rebalancingPeriod = userRebalancing || strategy.effectiveRebalancing || strategy.rebalancing || 'quarterly';
            const cacheKey = `${strategy.name}_${startDate}_${endDate}_${rebalancingPeriod}`;
            const cached = backtestCache.get(cacheKey);
            if (cached) {
                console.log(`캐시에서 로드: ${strategy.name}`);
                return cached;
            }

            console.log(`${strategy.name} 리밸런싱 주기: ${rebalancingPeriod}`);
            
            if (!allocation || Object.keys(allocation).length === 0) {
                console.warn('전략에 자산 배분 정보가 없습니다:', strategy.name);
                return [];
            }
            
            const symbols = Object.keys(allocation);
            const hasAllData = symbols.every(symbol => etfData[symbol] && etfData[symbol].length > 0);
            
            if (!hasAllData) {
                throw new Error(`${strategy.name}의 ETF 데이터가 불완전합니다. 누락된 ETF: ${symbols.filter(s => !etfData[s]).join(', ')}`);
            }
            
            const dates = generateDateRange(startDate, endDate);
            const portfolioValues = [];
            const actualAllocations = []; // 실제 비중 추적용 배열 추가
            let portfolioValue = 100;
            let lastRebalanceDate = null;
            let totalTradingCosts = 0;
            let rebalanceCount = 0; // 이 줄 추가
            
            // 초기 포지션 설정
            let holdings = {};
            for (const symbol in allocation) {
                const weight = allocation[symbol] / 100;
                const price = getETFPrice(symbol, dates[0], etfData);
                if (price) {
                    holdings[symbol] = {
                        shares: (portfolioValue * weight) / price,
                        initialPrice: price
                    };
                }
            }

            // 초기 포지션 설정 후 lastRebalanceDate 설정 (중복 리밸런싱 방지)
            lastRebalanceDate = dates[0];

            // 각 날짜별 포트폴리오 가치 계산
            for (let i = 0; i < dates.length; i++) {
                const date = dates[i];
                let currentValue = 0;
                let currentAllocation = {}; // 현재 시점의 실제 비중 저장용
                
                // 현재 보유 자산 가치 계산
                for (const symbol in holdings) {
                    const price = getETFPrice(symbol, date, etfData);
                    if (price) {
                        const assetValue = holdings[symbol].shares * price;
                        currentValue += assetValue;
                        currentAllocation[symbol] = assetValue; // 자산별 가치 저장
                    }
                }
                
                // 비중을 퍼센트로 변환
                if (currentValue > 0) {
                    for (const symbol in currentAllocation) {
                        currentAllocation[symbol] = (currentAllocation[symbol] / currentValue) * 100;
                    }
                }
                
                // 리밸런싱 확인
                if (shouldRebalance(date, lastRebalanceDate, rebalancingPeriod)) {
                    rebalanceCount++; // 이 줄 추가
                    portfolioValue = currentValue;
                    
                    // 리밸런싱 비용 계산
                    const rebalancingCost = portfolioValue * BACKTEST_ASSUMPTIONS.roundTripCost;
                    portfolioValue -= rebalancingCost;
                    totalTradingCosts += rebalancingCost;
                    
                    // 새로운 포지션 설정
                    holdings = {};
                    for (const symbol in allocation) {
                        const weight = allocation[symbol] / 100;
                        const price = getETFPrice(symbol, date, etfData);
                        if (price) {
                            holdings[symbol] = {
                                shares: (portfolioValue * weight) / price,
                                initialPrice: price
                            };
                        }
                    }
                    
                    lastRebalanceDate = date;
                }

                portfolioValue = currentValue;

                // 현금 비중이 있는 경우 현금 수익률 적용
                portfolioValue = applyCashReturn(portfolioValue, allocation);

                portfolioValues.push(portfolioValue);
                actualAllocations.push(currentAllocation); // 실제 비중 데이터도 저장
            }
            
            // 총 거래 비용을 콘솔에 출력
            console.log(`${strategy.name} 총 거래 비용: ${(totalTradingCosts / 100 * 100).toFixed(2)}%`);

            const result = {
                values: portfolioValues,
                allocations: actualAllocations,
                rebalanceCount: rebalanceCount
            };

            // ✅ 캐시에 저장
            backtestCache.set(cacheKey, result);
            if (backtestCache.size > 50) {
                const firstKey = backtestCache.keys().next().value;
                backtestCache.delete(firstKey);
            }

            return result;
        }

        // 현금 수익률 적용 (allocate smartly 기준)
        function applyCashReturn(portfolioValue, allocation) {
            const totalAllocated = Object.values(allocation).reduce((sum, weight) => sum + weight, 0);
            const cashWeight = 100 - totalAllocated;

            if (cashWeight > 0) {
                const cashReturn = BACKTEST_ASSUMPTIONS.cashReturnRate / 12; // 월간 수익률
                const cashValue = portfolioValue * (cashWeight / 100);
                const cashGain = cashValue * cashReturn;
                return portfolioValue + cashGain;
            }

            return portfolioValue;
        }

        // 성과 지표 계산
        function calculateMetrics(performanceData, strategy, startDate, endDate, skipBenchmark = false) {
            console.log('🔧 calculateMetrics 호출:', {
                strategyName: strategy?.name,
                performanceDataType: typeof performanceData,
                isArray: Array.isArray(performanceData),
                hasValues: !!performanceData?.values,
                startDate,
                endDate
            });

            const values = performanceData.values || performanceData;
            const rebalanceCount = performanceData.rebalanceCount || 0;

            console.log('🔧 values 추출 결과:', {
                valuesType: typeof values,
                isArray: Array.isArray(values),
                length: values?.length,
                first: values?.[0],
                last: values?.[values?.length - 1]
            });

            if (!values || values.length === 0) {
                console.error('❌ calculateMetrics 조기 종료: values가 비어있음');
                return {
                    totalReturn: 0,
                    annualReturn: 0,
                    volatility: 0,
                    maxDrawdown: 0,
                    sharpeRatio: 0,
                    calmarRatio: 0,
                    sortinoRatio: 0,
                    winRate: 0,
                    beta: 0,
                    alpha: 0,
                    correlation: 0,
                    rebalanceCount: 0,
                    // ✅ 새 지표들 기본값 추가
                    informationRatio: 0,
                    recoveryPeriod: 0,
                    maxWinStreak: 0,
                    maxLoseStreak: 0,
                    avgWinReturn: 0,
                    avgLossReturn: 0,
                    valueAtRisk95: 0,
                    tailRisk: 0
                };
            }

            const returns = [];
            for (let i = 1; i < values.length; i++) {
                returns.push((values[i] - values[i-1]) / values[i-1]);
            }

            // 총 수익률
            const totalReturn = ((values[values.length - 1] - values[0]) / values[0]) * 100;

            console.log('🔧 totalReturn 계산:', {
                initial: values[0],
                final: values[values.length - 1],
                totalReturn
            });

            // 연평균 수익률 - 정확한 날짜 차이로 계산
            const startDateObj = new Date(startDate);
            const endDateObj = new Date(endDate);
            const daysDiff = (endDateObj - startDateObj) / (1000 * 60 * 60 * 24);
            const years = daysDiff / 365.25; // 윤년 고려
            const annualReturn = years > 0 ? (Math.pow(values[values.length - 1] / values[0], 1 / years) - 1) * 100 : 0;

            // 변동성
            const meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
            const variance = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / returns.length;
            const volatility = Math.sqrt(variance) * Math.sqrt(12) * 100; // 연환산

            // 최대 낙폭 (MDD)
            let maxDrawdown = 0;
            let peak = values[0];
            for (const value of values) {
                if (value > peak) peak = value;
                const drawdown = ((value - peak) / peak) * 100;
                if (drawdown < maxDrawdown) maxDrawdown = drawdown;
            }

            // 벤치마크 데이터 (실제 SPY 데이터 사용) - SPY 자체 계산 시 건너뜀
            let benchmarkReturns = [];
            let benchmarkMeanReturn = 0;

            if (!skipBenchmark) {
                benchmarkReturns = generateBenchmarkReturns(returns.length, startDate, endDate);
                benchmarkMeanReturn = benchmarkReturns.reduce((a, b) => a + b, 0) / benchmarkReturns.length;
            }

            // 베타 계산 - skipBenchmark면 건너뜀
            let covariance = 0;
            let benchmarkVariance = 0;
            let beta = 0;
            let correlation = 0;
            let alpha = 0;
            let benchmarkAnnualReturn = 0;

            if (!skipBenchmark && benchmarkReturns.length > 0) {
                for (let i = 0; i < returns.length; i++) {
                    covariance += (returns[i] - meanReturn) * (benchmarkReturns[i] - benchmarkMeanReturn);
                    benchmarkVariance += Math.pow(benchmarkReturns[i] - benchmarkMeanReturn, 2);
                }
                covariance /= returns.length;
                benchmarkVariance /= returns.length;

                beta = benchmarkVariance !== 0 ? covariance / benchmarkVariance : 0;

                // 상관계수 계산
                const strategyStdDev = Math.sqrt(variance);
                const benchmarkStdDev = Math.sqrt(benchmarkVariance);
                correlation = (strategyStdDev !== 0 && benchmarkStdDev !== 0) ?
                    covariance / (strategyStdDev * benchmarkStdDev) : 0;

                // 알파 계산
                const riskFreeRate = 0.02 / 12; // 월간 무위험 수익률 (연 2%)
                benchmarkAnnualReturn = (benchmarkMeanReturn * 12) * 100;
                alpha = annualReturn - (2 + beta * (benchmarkAnnualReturn - 2)); // 연% 단위
            }
            
            // 샤프 비율
            const excessReturn = (annualReturn / 100) - 0.02; // 무위험 수익률 2%
            const sharpeRatio = volatility > 0 ? excessReturn / (volatility / 100) : 0;
            
            // 칼마 비율
            const calmarRatio = maxDrawdown !== 0 ? (annualReturn / Math.abs(maxDrawdown)) : 0;
            
            // 소르티노 비율 (MAR = 0 기준, 업계 표준)
            const MAR = 0; // Minimum Acceptable Return (목표 수익률)
            const downsideDeviations = returns.map(r => Math.min(r - MAR, 0));
            const downwardDeviation = Math.sqrt(
                downsideDeviations.reduce((sum, d) => sum + d * d, 0) / returns.length
            ) * Math.sqrt(12) * 100;
            const sortinoRatio = downwardDeviation > 0 ? excessReturn / (downwardDeviation / 100) : 0;
            
            // 승률
            const winningPeriods = returns.filter(r => r > 0).length;
            const winRate = (winningPeriods / returns.length) * 100;

            // 정보 비율 (Information Ratio) - skipBenchmark면 건너뜀
            let informationRatio = 0;
            if (!skipBenchmark && benchmarkReturns.length > 0) {
                const excessReturns = returns.map((r, i) => r - benchmarkReturns[i]);
                const trackingError = Math.sqrt(
                    excessReturns.reduce((sum, er) => sum + er * er, 0) / excessReturns.length
                ) * Math.sqrt(12) * 100;
                informationRatio = trackingError > 0 ?
                    (annualReturn - benchmarkAnnualReturn) / trackingError : 0;
            }
            
            // 회복 기간 (Recovery Period) - MDD 발생 후 고점 회복까지의 기간
            let recoveryPeriod = 0;
            let mddValue = 0;
            let mddIndex = 0;
            let peakBeforeMDD = values[0];
            let peakIndexBeforeMDD = 0;
            peak = values[0];

            // MDD와 해당 고점 찾기
            for (let i = 0; i < values.length; i++) {
                if (values[i] > peak) {
                    peak = values[i];
                    peakIndexBeforeMDD = i;
                }
                const drawdown = ((values[i] - peak) / peak) * 100;
                if (drawdown < mddValue) {
                    mddValue = drawdown;
                    mddIndex = i;
                    peakBeforeMDD = peak;
                }
            }

            // MDD 이후 고점 회복까지의 기간 계산
            if (mddIndex > 0) {
                for (let i = mddIndex + 1; i < values.length; i++) {
                    if (values[i] >= peakBeforeMDD) {
                        recoveryPeriod = i - peakIndexBeforeMDD;
                        break;
                    }
                }
                // 아직 회복하지 못한 경우 현재까지의 기간
                if (recoveryPeriod === 0) {
                    recoveryPeriod = values.length - 1 - peakIndexBeforeMDD;
                }
            }
            
            // 연속 상승/하락
            let currentWinStreak = 0;
            let currentLoseStreak = 0;
            let maxWinStreak = 0;
            let maxLoseStreak = 0;
            
            returns.forEach(r => {
                if (r > 0) {
                    currentWinStreak++;
                    currentLoseStreak = 0;
                    if (currentWinStreak > maxWinStreak) maxWinStreak = currentWinStreak;
                } else if (r < 0) {
                    currentLoseStreak++;
                    currentWinStreak = 0;
                    if (currentLoseStreak > maxLoseStreak) maxLoseStreak = currentLoseStreak;
                }
            });
            
            // 평균 상승폭/하락폭
            const winReturns = returns.filter(r => r > 0);
            const loseReturns = returns.filter(r => r < 0);
            const avgWinReturn = winReturns.length > 0 ?
                (winReturns.reduce((a, b) => a + b, 0) / winReturns.length) * 100 : 0;
            const avgLossReturn = loseReturns.length > 0 ?
                (loseReturns.reduce((a, b) => a + b, 0) / loseReturns.length) * 100 : 0;
            
            // VaR (95%)
            const sortedReturns = [...returns].sort((a, b) => a - b);
            const varIndex = Math.floor(sortedReturns.length * 0.05);
            const valueAtRisk95 = sortedReturns[varIndex] * 100;
            
            // 꼬리 위험 (최악의 5% 평균)
            const tailReturns = sortedReturns.slice(0, varIndex);
            const tailRisk = tailReturns.length > 0 ?
                (tailReturns.reduce((a, b) => a + b, 0) / tailReturns.length) * 100 : 0;
            
            return {
                totalReturn: totalReturn,
                annualReturn: annualReturn,
                volatility: volatility,
                maxDrawdown: maxDrawdown,
                sharpeRatio: sharpeRatio,
                calmarRatio: calmarRatio,
                sortinoRatio: sortinoRatio,
                winRate: winRate,
                beta: beta,
                alpha: alpha,
                correlation: correlation,
                rebalanceCount: rebalanceCount,
                // ✅ 새 지표들 추가
                informationRatio: informationRatio,
                recoveryPeriod: recoveryPeriod,
                maxWinStreak: maxWinStreak,
                maxLoseStreak: maxLoseStreak,
                avgWinReturn: avgWinReturn,
                avgLossReturn: avgLossReturn,
                valueAtRisk95: valueAtRisk95,
                tailRisk: tailRisk
            };
        }

        let drawdownChart = null; // 전역 변수 추가

        function createDrawdownChart() {
            const ctx = document.getElementById('drawdown-chart')?.getContext('2d');
            if (!ctx) return;

            // 기존 차트 파괴
            if (drawdownChart) {
                drawdownChart.destroy();
            }

            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const dates = generateDateRange(startDate, endDate);

            const datasets = selectedStrategies.map(strategyId => {
                const strategy = strategies[strategyId];
                const performanceData = portfolioTimeSeries[strategyId];
                const values = performanceData.values || performanceData;

                const drawdowns = [];
                let peak = values[0];
                let maxDD = 0;
                let maxDDIndex = 0;

                for (let i = 0; i < values.length; i++) {
                    const value = values[i];
                    if (value > peak) peak = value;
                    const dd = ((value - peak) / peak) * 100;
                    drawdowns.push(dd);

                    // 최대 드로다운 위치 찾기
                    if (dd < maxDD) {
                        maxDD = dd;
                        maxDDIndex = i;
                    }
                }

                return {
                    label: strategy.name,
                    data: drawdowns,
                    borderColor: strategy.color,
                    backgroundColor: strategy.color + '40',
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    maxDDIndex: maxDDIndex,
                    maxDD: maxDD
                };
            });

            const labels = dates.map(d => `${d.getFullYear()}-${(d.getMonth()+1).toString().padStart(2,'0')}`);

            drawdownChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: isDarkMode ? '#ffffff' : '#000000',
                                font: { size: 12 }
                            }
                        },
                        tooltip: {
                            backgroundColor: isDarkMode ? 'rgba(0,0,0,0.9)' : 'rgba(255,255,255,0.9)',
                            titleColor: isDarkMode ? '#ffffff' : '#000000',
                            bodyColor: isDarkMode ? '#ffffff' : '#000000',
                            borderColor: isDarkMode ? '#333' : '#ddd',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const strategyName = context.dataset.label;
                                    const value = context.parsed.y;
                                    return `${strategyName}: ${value.toFixed(2)}%`;
                                },
                                footer: function(context) {
                                    const index = context[0].dataIndex;
                                    let footer = [];
                                    datasets.forEach(ds => {
                                        if (index === ds.maxDDIndex) {
                                            footer.push(`⚠️ ${ds.label} 최대 드로다운: ${ds.maxDD.toFixed(2)}%`);
                                        }
                                    });
                                    return footer.join('\n');
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            reverse: false, // false로 변경 (0이 위, 음수가 아래)
                            max: 0,
                            ticks: {
                                color: isDarkMode ? '#8E8E93' : '#666',
                                callback: v => v.toFixed(1) + '%'
                            },
                            grid: {
                                color: isDarkMode ? '#333' : '#e0e0e0'
                            },
                            title: {
                                display: true,
                                text: '고점 대비 낙폭 (%)',
                                color: isDarkMode ? '#ffffff' : '#000000',
                                font: { size: 13 }
                            }
                        },
                        x: {
                            ticks: {
                                color: isDarkMode ? '#8E8E93' : '#666',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: isDarkMode ? '#222' : '#f0f0f0'
                            }
                        }
                    }
                }
            });
        }

        // 히트맵에 표시할 전략 목록 (전역 변수)
        let heatmapSelectedStrategies = [];
        let correlationSelectedStrategies = [];
        let yearlySelectedStrategies = [];

        // 히트맵 전략 선택기 업데이트
        function updateHeatmapStrategySelector() {
            const selector = document.getElementById('heatmap-strategy-selector');
            if (!selector) return;

            if (selectedStrategies.length === 0) {
                selector.innerHTML = '';
                heatmapSelectedStrategies = [];
                return;
            }

            // 초기화: 모든 전략 선택
            if (heatmapSelectedStrategies.length === 0) {
                heatmapSelectedStrategies = [...selectedStrategies];
            }

            // 선택기 버튼 생성
            let html = '';
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const isSelected = heatmapSelectedStrategies.includes(strategyId);

                html += `
                    <button
                        onclick="toggleHeatmapStrategy('${strategyId}')"
                        style="
                            padding: 6px 12px;
                            border-radius: 6px;
                            border: 2px solid ${strategy.color};
                            background: ${isSelected ? strategy.color : 'transparent'};
                            color: ${isSelected ? '#fff' : (isDarkMode ? '#fff' : '#000')};
                            font-size: 12px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.2s;
                        "
                    >
                        ${strategy.name}
                    </button>
                `;
            });

            selector.innerHTML = html;
        }

        // 히트맵 전략 토글
        function toggleHeatmapStrategy(strategyId) {
            const index = heatmapSelectedStrategies.indexOf(strategyId);

            if (index > -1) {
                // 최소 1개는 선택되어야 함
                if (heatmapSelectedStrategies.length === 1) {
                    showNotification('최소 1개의 전략을 선택해야 합니다.', 'warning', 2000);
                    return;
                }
                heatmapSelectedStrategies.splice(index, 1);
            } else {
                heatmapSelectedStrategies.push(strategyId);
            }

            updateHeatmapStrategySelector();
            createMonthlyReturnsHeatmap();
        }

        // 상관관계 매트릭스 전략 선택기 업데이트
        function updateCorrelationStrategySelector() {
            const selector = document.getElementById('correlation-strategy-selector');
            if (!selector) return;

            if (selectedStrategies.length === 0) {
                selector.innerHTML = '';
                correlationSelectedStrategies = [];
                return;
            }

            // 초기화: 모든 전략 선택
            if (correlationSelectedStrategies.length === 0) {
                correlationSelectedStrategies = [...selectedStrategies];
            }

            // 선택기 버튼 생성
            let html = '';
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const isSelected = correlationSelectedStrategies.includes(strategyId);

                html += `
                    <button
                        onclick="toggleCorrelationStrategy('${strategyId}')"
                        style="
                            padding: 6px 12px;
                            border-radius: 6px;
                            border: 2px solid ${strategy.color};
                            background: ${isSelected ? strategy.color : 'transparent'};
                            color: ${isSelected ? '#fff' : (isDarkMode ? '#fff' : '#000')};
                            font-size: 12px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.2s;
                        "
                    >
                        ${strategy.name}
                    </button>
                `;
            });

            selector.innerHTML = html;
        }

        // 상관관계 매트릭스 전략 토글
        function toggleCorrelationStrategy(strategyId) {
            const index = correlationSelectedStrategies.indexOf(strategyId);

            if (index > -1) {
                // 최소 2개는 선택되어야 함 (상관관계 계산을 위해)
                if (correlationSelectedStrategies.length === 2) {
                    showNotification('상관관계 계산을 위해 최소 2개의 전략을 선택해야 합니다.', 'warning', 2000);
                    return;
                }
                correlationSelectedStrategies.splice(index, 1);
            } else {
                correlationSelectedStrategies.push(strategyId);
            }

            updateCorrelationStrategySelector();
            generateRealCorrelationMatrix();
        }

        // 연도별 성과 전략 선택기 업데이트
        function updateYearlyStrategySelector() {
            const selector = document.getElementById('yearly-strategy-selector');
            if (!selector) return;

            if (selectedStrategies.length === 0) {
                selector.innerHTML = '';
                yearlySelectedStrategies = [];
                return;
            }

            // 초기화: 모든 전략 선택
            if (yearlySelectedStrategies.length === 0) {
                yearlySelectedStrategies = [...selectedStrategies];
            }

            // 선택기 버튼 생성
            let html = '';
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const isSelected = yearlySelectedStrategies.includes(strategyId);

                html += `
                    <button
                        onclick="toggleYearlyStrategy('${strategyId}')"
                        style="
                            padding: 6px 12px;
                            border-radius: 6px;
                            border: 2px solid ${strategy.color};
                            background: ${isSelected ? strategy.color : 'transparent'};
                            color: ${isSelected ? '#fff' : (isDarkMode ? '#fff' : '#000')};
                            font-size: 12px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.2s;
                        "
                    >
                        ${strategy.name}
                    </button>
                `;
            });

            selector.innerHTML = html;
        }

        // 연도별 성과 전략 토글
        function toggleYearlyStrategy(strategyId) {
            const index = yearlySelectedStrategies.indexOf(strategyId);

            if (index > -1) {
                // 최소 1개는 선택되어야 함
                if (yearlySelectedStrategies.length === 1) {
                    showNotification('최소 1개의 전략을 선택해야 합니다.', 'warning', 2000);
                    return;
                }
                yearlySelectedStrategies.splice(index, 1);
            } else {
                yearlySelectedStrategies.push(strategyId);
            }

            updateYearlyStrategySelector();
            generateAdvancedYearlyPerformance();
        }

        function createMonthlyReturnsHeatmap() {
            const container = document.getElementById('monthly-heatmap');
            if (!container) return;

            if (selectedStrategies.length === 0) {
                container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">전략을 선택해주세요</p>';
                return;
            }

            if (heatmapSelectedStrategies.length === 0) {
                container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">표시할 전략을 선택해주세요</p>';
                return;
            }

            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const dates = generateDateRange(startDate, endDate);

            let html = '';

            // 각 선택된 전략에 대해 히트맵 생성
            heatmapSelectedStrategies.forEach((strategyId, index) => {
                const strategy = strategies[strategyId];
                const performanceData = portfolioTimeSeries[strategyId];

                if (!performanceData || !performanceData.values) {
                    html += `<p style="text-align:center; color: var(--text-secondary); margin: 20px 0;">${strategy.name}: 백테스트를 먼저 실행해주세요</p>`;
                    return;
                }

                const values = performanceData.values;

                // 월별 수익률 계산
                const monthlyReturns = [];
                for (let i = 1; i < dates.length; i++) {
                    const returnPct = ((values[i] - values[i-1]) / values[i-1]) * 100;
                    monthlyReturns.push({
                        year: dates[i].getFullYear(),
                        month: dates[i].getMonth() + 1,
                        return: returnPct
                    });
                }

                // 연도와 월 추출
                const years = [...new Set(monthlyReturns.map(r => r.year))].sort();
                const months = ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'];

                // 히트맵 HTML 생성
                html += `
                    <div style="margin-bottom: ${index < heatmapSelectedStrategies.length - 1 ? '32px' : '0'};">
                        <div style="margin-bottom: 12px; color: ${isDarkMode ? '#fff' : '#000'}; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                            <div style="width: 8px; height: 8px; border-radius: 50%; background: ${strategy.color};"></div>
                            ${strategy.name} - 월별 수익률 (%)
                        </div>
                        <div style="overflow-x: auto;">
                            <table class="heatmap-table" style="border-collapse: collapse; font-size: 11px; min-width: 800px;">
                                <thead>
                                    <tr>
                                        <th style="padding: 8px; text-align: center; background: ${isDarkMode ? '#2A2A2A' : '#f5f5f5'}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'};">연도</th>
                `;

                months.forEach(month => {
                    html += `<th style="padding: 8px; text-align: center; background: ${isDarkMode ? '#2A2A2A' : '#f5f5f5'}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'};">${month}</th>`;
                });

                html += `<th style="padding: 8px; text-align: center; background: ${isDarkMode ? '#2A2A2A' : '#f5f5f5'}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'}; font-weight: 700;">연간</th></tr></thead><tbody>`;

                years.forEach(year => {
                    html += `<tr><td style="padding: 8px; text-align: center; background: ${isDarkMode ? '#2A2A2A' : '#f5f5f5'}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'}; font-weight: 600;">${year}</td>`;

                    let yearTotal = 1;
                    for (let month = 1; month <= 12; month++) {
                        const data = monthlyReturns.find(r => r.year === year && r.month === month);

                        if (data) {
                            const returnVal = data.return;
                            yearTotal *= (1 + returnVal / 100);

                            // 색상 결정 (-5% ~ +5% 범위)
                            const intensity = Math.min(Math.abs(returnVal) / 5, 1);
                            let bgColor;
                            if (returnVal > 0) {
                                bgColor = `rgba(50, 215, 75, ${intensity * 0.7})`;
                            } else if (returnVal < 0) {
                                bgColor = `rgba(255, 59, 48, ${intensity * 0.7})`;
                            } else {
                                bgColor = isDarkMode ? '#1A1A1A' : '#ffffff';
                            }

                            html += `<td style="padding: 8px; text-align: center; background: ${bgColor}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'}; color: ${isDarkMode ? '#fff' : '#000'};">${returnVal.toFixed(1)}</td>`;
                        } else {
                            html += `<td style="padding: 8px; text-align: center; background: ${isDarkMode ? '#1A1A1A' : '#ffffff'}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'}; color: #666;">-</td>`;
                        }
                    }

                    // 연간 수익률
                    const yearReturn = (yearTotal - 1) * 100;
                    const yearIntensity = Math.min(Math.abs(yearReturn) / 20, 1);
                    const yearBgColor = yearReturn > 0
                        ? `rgba(50, 215, 75, ${yearIntensity * 0.7})`
                        : `rgba(255, 59, 48, ${yearIntensity * 0.7})`;

                    html += `<td style="padding: 8px; text-align: center; background: ${yearBgColor}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'}; font-weight: 700; color: ${isDarkMode ? '#fff' : '#000'};">${yearReturn.toFixed(1)}</td></tr>`;
                });

                html += '</tbody></table></div></div>';
            });

            // 범례 추가 (한 번만)
            html += `
                <div style="margin-top: 16px; display: flex; align-items: center; justify-content: center; gap: 20px; font-size: 12px;">
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 20px; height: 20px; background: rgba(255, 59, 48, 0.7); border-radius: 3px;"></div>
                        <span style="color: ${isDarkMode ? '#8E8E93' : '#666'};">손실</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 20px; height: 20px; background: ${isDarkMode ? '#1A1A1A' : '#ffffff'}; border: 1px solid ${isDarkMode ? '#333' : '#ddd'}; border-radius: 3px;"></div>
                        <span style="color: ${isDarkMode ? '#8E8E93' : '#666'};">데이터 없음</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 20px; height: 20px; background: rgba(50, 215, 75, 0.7); border-radius: 3px;"></div>
                        <span style="color: ${isDarkMode ? '#8E8E93' : '#666'};">이익</span>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // 벤치마크 수익률 생성 함수 추가
        function generateBenchmarkReturns(length, startDate, endDate) {
            // SPY ETF 데이터가 있는지 확인
            if (!localETFData['SPY'] || localETFData['SPY'].length === 0) {
                console.error('SPY 데이터가 없습니다. Beta, Alpha, Correlation 등의 벤치마크 지표를 계산할 수 없습니다.');
                // SPY 데이터가 없으면 0으로 채운 배열 반환 (벤치마크 지표는 0으로 표시됨)
                const returns = new Array(length).fill(0);
                return returns;
            }
            
            // 실제 SPY 데이터로 수익률 계산
            const dates = generateDateRange(startDate, endDate);
            const returns = [];
            
            for (let i = 1; i < dates.length; i++) {
                const currentPrice = getETFPrice('SPY', dates[i], localETFData);
                const previousPrice = getETFPrice('SPY', dates[i-1], localETFData);
                
                if (currentPrice && previousPrice && previousPrice !== 0) {
                    const monthlyReturn = (currentPrice - previousPrice) / previousPrice;
                    returns.push(monthlyReturn);
                } else {
                    // 데이터가 없는 경우 이전 수익률 사용 또는 0
                    returns.push(returns.length > 0 ? returns[returns.length - 1] : 0);
                }
            }
            
            return returns;
        }

        function createComparisonChart() {
            const ctx = document.getElementById('comparison-chart').getContext('2d');
            
            if (comparisonChart) {
                comparisonChart.destroy();
            }
            
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const isMobile = window.innerWidth <= 768;
            
            try {
                const datasets = selectedStrategies.map(strategyId => {
                    const strategy = strategies[strategyId];
                    
                    // 저장된 시계열 데이터 사용
                    let performanceData;
                    if (portfolioTimeSeries[strategyId]) {
                        performanceData = portfolioTimeSeries[strategyId];
                    } else {
                        performanceData = calculatePortfolioPerformance(
                            strategy,
                            startDate,
                            endDate,
                            localETFData
                        );
                    }
                    
                    // *** 여기를 수정 ***
                    // performanceData가 객체인 경우 values 속성 사용
                    const values = performanceData.values || performanceData;
                    const percentageData = values.map(v => ((v - 100) / 100) * 100);
                    
                    return {
                        label: strategy.name,
                        data: percentageData,
                        borderColor: strategy.color,
                        backgroundColor: strategy.color + '20',
                        borderWidth: isMobile ? 3 : 2,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: isMobile ? 8 : 6,
                        pointBackgroundColor: strategy.color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    };
                });
                
                const dates = generateDateRange(startDate, endDate);
                const labels = dates.map(d => {
                    const month = d.getMonth() + 1;
                    const year = d.getFullYear();
                    return `${year}-${month.toString().padStart(2, '0')}`;
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: isMobile ? 'bottom' : 'top',
                                labels: {
                                    color: isDarkMode ? '#F9FAFB' : '#111827',
                                    font: { size: isMobile ? 10 : 12 },
                                    padding: isMobile ? 8 : 12,
                                    usePointStyle: true
                                }
                            },
                            tooltip: {
                                enabled: true,
                                backgroundColor: isDarkMode ? 'rgba(0, 0, 0, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                                titleColor: isDarkMode ? '#F9FAFB' : '#111827',
                                bodyColor: isDarkMode ? '#F9FAFB' : '#111827',
                                borderColor: isDarkMode ? '#2D333B' : '#E5E7EB',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: true,
                                boxPadding: 6,
                                usePointStyle: true,
                                yAlign: 'bottom',
                                xAlign: 'center',
                                caretPadding: 10,
                                titleFont: {
                                    size: 13,
                                    weight: 'bold'
                                },
                                bodyFont: {
                                    size: 12
                                },
                                bodySpacing: 6,
                                callbacks: {
                                    title: function(context) {
                                        return context[0].label;
                                    },
                                    label: function(context) {
                                        const strategyId = selectedStrategies[context.datasetIndex];
                                        const strategy = strategies[strategyId];
                                        const value = context.parsed.y;

                                        return `${strategy.name}: ${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    color: isDarkMode ? '#9CA3AF' : '#111827',
                                    font: { size: isMobile ? 9 : 11 },
                                    maxRotation: 45,
                                    minRotation: 0
                                },
                                grid: {
                                    color: isDarkMode ? '#2D333B' : '#F1F3F5'
                                }
                            },
                            y: {
                                ticks: {
                                    color: isDarkMode ? '#9CA3AF' : '#111827',
                                    callback: value => value.toFixed(0) + '%',
                                    font: { size: isMobile ? 10 : 12 }
                                },
                                grid: {
                                    color: isDarkMode ? '#2D333B' : '#F1F3F5'
                                },
                                title: {
                                    display: true,
                                    text: '누적 수익률 (%)',
                                    color: isDarkMode ? '#F9FAFB' : '#111827',
                                    font: {
                                        size: 13,
                                        weight: 'bold'
                                    }
                                }
                            }
                        }
                    }
                });
                
                updateMetricsDisplay();
                
            } catch (error) {
                console.error('Chart error:', error);
                showNotification('차트 생성 실패', 'error');
            }
        }

        // 실제 데이터로 지표 업데이트
        function updateMetricsWithRealData() {
            const container = document.getElementById('metrics-grid');
            container.innerHTML = '';
            
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const performanceData = calculatePortfolioPerformance(
                    strategy,
                    startDate,
                    endDate,
                    localETFData
                );

                const metrics = calculateMetrics(performanceData, strategy, startDate, endDate);
                
                container.innerHTML += `
                    <div class="metric-item">
                        <div class="metric-value ${metrics.totalReturn >= 0 ? 'text-green' : 'text-red'}">
                            ${metrics.totalReturn >= 0 ? '+' : ''}${Math.round(metrics.totalReturn)}%
                        </div>
                        <div class="metric-label">${strategy.name} 수익률</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value text-red">${Math.round(metrics.maxDrawdown)}%</div>
                        <div class="metric-label">${strategy.name} MDD</div>
                    </div>
                `;
            });
        }

        function updateMetricsDisplay() {
            const container = document.getElementById('metrics-grid');
            container.innerHTML = '';

            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const metrics = backtestResults[strategyId];

                if (!metrics) {
                    console.warn(`${strategy.name}의 백테스트 결과가 없습니다.`);
                    return;
                }

                // 전략별 카드 생성
                container.innerHTML += `
                    <div style="grid-column: 1 / -1; background: var(--bg-secondary); border: 1px solid var(--border-medium); border-radius: 12px; padding: 20px; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border-subtle);">
                            <div style="width: 8px; height: 8px; border-radius: 50%; background: ${strategy.color}; margin-right: 12px;"></div>
                            <h3 style="margin: 0; font-size: 18px; font-weight: 600; color: var(--text-primary);">${strategy.name}</h3>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 16px;">
                            <div class="metric-item" onclick="showMetricExplanation('totalReturn', ${metrics.totalReturn})" style="cursor: pointer; padding: 16px;">
                                <div class="metric-label" style="margin-bottom: 8px; font-size: 13px;">
                                    누적 수익률<br><span style="font-size: 11px; opacity: 0.7;">(Total Return)</span>
                                    <span class="help-icon-inline">?</span>
                                </div>
                                <div class="metric-value ${metrics.totalReturn >= 0 ? 'text-green' : 'text-red'}" style="font-size: 28px;">
                                    ${metrics.totalReturn >= 0 ? '+' : ''}${Math.round(metrics.totalReturn)}%
                                </div>
                            </div>
                            <div class="metric-item" onclick="showMetricExplanation('maxDrawdown', ${metrics.maxDrawdown})" style="cursor: pointer; padding: 16px;">
                                <div class="metric-label" style="margin-bottom: 8px; font-size: 13px;">
                                    최대 낙폭<br><span style="font-size: 11px; opacity: 0.7;">(MDD)</span>
                                    <span class="help-icon-inline">?</span>
                                </div>
                                <div class="metric-value text-red" style="font-size: 28px;">
                                    ${Math.round(metrics.maxDrawdown)}%
                                </div>
                            </div>
                            <div class="metric-item" onclick="showMetricExplanation('sharpeRatio', ${metrics.sharpeRatio})" style="cursor: pointer; padding: 16px;">
                                <div class="metric-label" style="margin-bottom: 8px; font-size: 13px;">
                                    샤프 비율<br><span style="font-size: 11px; opacity: 0.7;">(Sharpe Ratio)</span>
                                    <span class="help-icon-inline">?</span>
                                </div>
                                <div class="metric-value text-blue" style="font-size: 28px;">
                                    ${metrics.sharpeRatio.toFixed(2)}
                                </div>
                            </div>
                            <div class="metric-item" onclick="showMetricExplanation('winRate', ${metrics.winRate})" style="cursor: pointer; padding: 16px;">
                                <div class="metric-label" style="margin-bottom: 8px; font-size: 13px;">
                                    승률<br><span style="font-size: 11px; opacity: 0.7;">(Win Rate)</span>
                                    <span class="help-icon-inline">?</span>
                                </div>
                                <div class="metric-value ${metrics.winRate >= 50 ? 'text-green' : 'text-red'}" style="font-size: 28px;">
                                    ${Math.round(metrics.winRate)}%
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
        }


        // 포트폴리오 차트 생성
        // 5% 단위로 반올림하는 헬퍼 함수
        function roundTo5Percent(num) {
            return Math.round(num / 5) * 5;
        }

        function createPortfolioCharts() {
            const container = document.getElementById('pie-charts-container');
            container.innerHTML = '';

            pieCharts.forEach(chart => {
                if (chart) chart.destroy();
            });
            pieCharts = [];
            
            selectedStrategies.forEach((strategyId, index) => {
                const strategy = strategies[strategyId];

                // Allocations에 정의된 기준 비중 사용
                const actualAllocation = strategy.allocation || strategy.etfs;

                const chartWrapper = document.createElement('div');
                chartWrapper.className = 'pie-chart-wrapper';

                const title = document.createElement('div');
                title.className = 'pie-chart-title';
                title.textContent = `${strategy.name} - 목표 자산배분`;
                chartWrapper.appendChild(title);
                
                const chartContainer = document.createElement('div');
                chartContainer.className = 'pie-chart-container';
                
                const canvas = document.createElement('canvas');
                canvas.id = `pie-chart-${index}`;
                chartContainer.appendChild(canvas);
                chartWrapper.appendChild(chartContainer);
                
                const legend = createAllocationLegend(actualAllocation);
                chartWrapper.appendChild(legend);
                container.appendChild(chartWrapper);
                
                const ctx = canvas.getContext('2d');
                const pieChart = createPieChart(ctx, { allocation: actualAllocation });
                pieCharts.push(pieChart);
            });
        }

        function createPieChart(ctx, strategy) {
            const allocation = strategy.allocation || strategy.etfs || {};
            
            if (Object.keys(allocation).length === 0) {
                allocation = { 'No Data': 100 };
            }
            
            const labels = Object.keys(allocation);
            const data = Object.values(allocation);
            // 라이트/다크 모드별 차트 색상 팔레트
            const lightColors = ['#16A34A', '#2563EB', '#D97706', '#7C3AED', '#DC2626', '#0D9488', '#EA580C', '#0284C7', '#9333EA', '#CA8A04'];
            const darkColors = ['#22C55E', '#3B82F6', '#F59E0B', '#8B5CF6', '#EF4444', '#14B8A6', '#F97316', '#0EA5E9', '#A855F7', '#EAB308'];
            const colors = isDarkMode ? darkColors : lightColors;
            
            return new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors.slice(0, labels.length),
                        borderColor: isDarkMode ? '#2A2A2A' : '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: context => `${context.label}: ${roundTo5Percent(context.parsed)}%`
                            }
                        }
                    }
                }
            });
        }

        function createAllocationLegend(allocation) {
            const legend = document.createElement('div');
            legend.className = 'allocation-legend';
            
            if (!allocation || Object.keys(allocation).length === 0) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.textContent = '배분 정보 없음';
                legend.appendChild(item);
                return legend;
            }

            // 라이트/다크 모드별 차트 색상 팔레트
            const lightColors = ['#16A34A', '#2563EB', '#D97706', '#7C3AED', '#DC2626', '#0D9488', '#EA580C', '#0284C7', '#9333EA', '#CA8A04'];
            const darkColors = ['#22C55E', '#3B82F6', '#F59E0B', '#8B5CF6', '#EF4444', '#14B8A6', '#F97316', '#0EA5E9', '#A855F7', '#EAB308'];
            const colors = isDarkMode ? darkColors : lightColors;

            Object.entries(allocation).forEach(([asset, percentage], index) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.style.cursor = 'pointer';
                item.title = '클릭하여 ETF 정보 보기';

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = colors[index % colors.length];

                const label = document.createElement('span');
                const info = etfInfo[asset];
                if (info) {
                    label.innerHTML = `<strong>${asset}</strong> (${info.category}): ${roundTo5Percent(percentage)}%`;
                } else {
                    label.textContent = `${asset}: ${roundTo5Percent(percentage)}%`;
                }

                // ETF 정보 클릭 이벤트
                item.onclick = () => showETFInfo(asset);

                item.appendChild(colorBox);
                item.appendChild(label);
                legend.appendChild(item);
            });
            
            return legend;
        }


        function updateRealRebalancingSimulation() {
            const userRebalancing = document.getElementById('user-rebalancing-override');
            const period = userRebalancing ? userRebalancing.value : 'quarterly';
            
            // 실제 백테스트 결과가 있는지 확인
            let totalRebalances = 0;
            let hasActualData = false;
            
            selectedStrategies.forEach(strategyId => {
                const results = backtestResults[strategyId];
                if (results && typeof results.rebalanceCount === 'number') {
                    totalRebalances += results.rebalanceCount;
                    hasActualData = true;
                }
            });
            
            const container = document.querySelector('.rebalancing-analysis');
            if (!container) return;
            
            if (hasActualData && selectedStrategies.length > 0) {
                // 실제 백테스트 데이터 사용
                const avgRebalances = Math.round(totalRebalances / selectedStrategies.length);
                const actualCost = (avgRebalances * 0.2).toFixed(2);
                
                container.innerHTML = `
                    <div class="rebalancing-metric">
                        <div class="metric-title">실제 리밸런싱</div>
                        <div class="metric-value">${avgRebalances}회</div>
                    </div>
                    <div class="rebalancing-metric">
                        <div class="metric-title">실제 거래비용</div>
                        <div class="metric-value text-red">${actualCost}%</div>
                    </div>
                    <div class="rebalancing-metric">
                        <div class="metric-title">설정 주기</div>
                        <div class="metric-value">${getRebalancingPeriodName(period)}</div>
                    </div>
                    <div class="rebalancing-metric">
                        <div class="metric-title">데이터 기준</div>
                        <div class="metric-value text-blue">실제 결과</div>
                    </div>
                `;
            } else {
                // 예상 계산 사용 (기존 로직)
                const startDate = document.getElementById('start-date').value;
                const endDate = document.getElementById('end-date').value;
                const dateRange = generateDateRange(startDate, endDate);
                const totalMonths = dateRange.length;
                
                let frequency = 0;
                
                switch(period) {
                    case 'monthly': frequency = totalMonths; break;
                    case 'quarterly': frequency = Math.ceil(totalMonths / 3); break;
                    case 'semiannual': frequency = Math.ceil(totalMonths / 6); break;
                    case 'annual': frequency = Math.ceil(totalMonths / 12); break;
                    case 'none': frequency = 0; break;
                }
                
                const cost = (frequency * 0.2).toFixed(2);
                
                container.innerHTML = `
                    <div class="rebalancing-metric">
                        <div class="metric-title">예상 리밸런싱</div>
                        <div class="metric-value">${frequency}회</div>
                    </div>
                    <div class="rebalancing-metric">
                        <div class="metric-title">예상 거래비용</div>
                        <div class="metric-value text-red">${cost}%</div>
                    </div>
                    <div class="rebalancing-metric">
                        <div class="metric-title">설정 주기</div>
                        <div class="metric-value">${getRebalancingPeriodName(period)}</div>
                    </div>
                    <div class="rebalancing-metric">
                        <div class="metric-title">데이터 기준</div>
                        <div class="metric-value text-yellow">예상값</div>
                    </div>
                `;
            }
        }

        function getRebalancingPeriodName(period) {
            const names = {
                'monthly': '매월',
                'quarterly': '분기별',
                'semiannual': '반기별',
                'annual': '연간',
                'none': '없음'
            };
            return names[period] || '분기별';
        }

        function calculateRealRebalancingEffect(period, threshold) {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const dateRange = generateDateRange(startDate, endDate);
            const totalMonths = dateRange.length;
            
            let frequency = 0;
            
            switch(period) {
                case 'monthly': frequency = totalMonths; break;
                case 'quarterly': frequency = Math.ceil(totalMonths / 3); break;
                case 'semiannual': frequency = Math.ceil(totalMonths / 6); break;
                case 'annual': frequency = Math.ceil(totalMonths / 12); break;
                case 'none': frequency = 0; break;
            }
            
            // 실제 거래 비용 계산 (0.2% per rebalancing)
            const cost = (frequency * 0.2).toFixed(2);
            
            // 리밸런싱 효과는 변동성 감소 효과로 추정
            let effect = 0;
            if (frequency > 0) {
                // 높은 빈도일수록 약간의 성과 개선 (드래그 효과 고려)
                effect = Math.max(-1.0, Math.min(1.5, frequency * 0.1 - parseFloat(cost)));
            }
            
            // 드리프트 감소 효과
            const driftReduction = frequency > 0 ? Math.min(90, frequency * 5 + 10) : 0;
            
            return { 
                frequency, 
                cost, 
                effect: effect.toFixed(2), 
                driftReduction: driftReduction.toFixed(2) 
            };
        }

        // 나머지 필수 함수들
        function generateAllRealAnalysisData() {
            updateMetricsDisplay();
            generateRealDetailedMetrics();
            generateRealYearlyPerformance();
            // generateRealBenchmarkComparison(); // 벤치마크 비교 기능 제거됨
            createPortfolioCharts();
            updateRealRebalancingSimulation();
            displayAssetContributions();
            displayRebalancingEffect();
        }
        
        function displayAssetContributions() {
            // 포트폴리오 탭에 자산별 기여도 추가
            const container = document.querySelector('.rebalancing-analysis');
            if (!container) return;
            
            let html = '<h4 style="margin-top: 30px;">자산별 기여도 분석</h4>';
            
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const contributions = calculateAssetContribution(strategyId);
                
                html += `<div style="margin: 20px 0;">
                    <h5>${strategy.name}</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">`;
                
                Object.entries(contributions).forEach(([symbol, data]) => {
                    html += `
                        <div class="rebalancing-metric">
                            <div class="metric-title">${symbol}</div>
                            <div class="metric-value">${data.weight.toFixed(1)}%</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">
                                기여: ${data.contribution >= 0 ? '+' : ''}${data.contribution.toFixed(2)}%
                            </div>
                        </div>`;
                });
                
                html += '</div></div>';
            });
            
            container.insertAdjacentHTML('beforeend', html);
        }

        function calculateAssetContribution(strategyId) {
            const strategy = strategies[strategyId];
            const allocation = strategy.allocation || strategy.etfs;
            const contributions = {};
            const metrics = backtestResults[strategyId];
            
            if (!metrics) return contributions;
            
            Object.keys(allocation).forEach(symbol => {
                const weight = allocation[symbol] / 100;
                contributions[symbol] = {
                    weight: allocation[symbol],
                    contribution: weight * metrics.totalReturn // 간단한 근사치
                };
            });
            
            return contributions;
        }

        function displayRebalancingEffect() {
            // 구현 생략 (복잡함)
        }
        
        // 로딩 및 피드백 시스템
        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;

            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }

        // 지표 설명 모달 표시
        function showMetricExplanation(metricKey, value) {
            const explanation = metricExplanations[metricKey];
            if (!explanation) return;

            // 값에 따른 해석 결정
            let interpretationText = '';
            if (metricKey === 'sharpeRatio') {
                if (value >= 2.0) interpretationText = explanation.interpretation.high;
                else if (value >= 1.0) interpretationText = explanation.interpretation.medium;
                else interpretationText = explanation.interpretation.low;
            } else if (metricKey === 'maxDrawdown') {
                if (value >= -10) interpretationText = explanation.interpretation.high;
                else if (value >= -20) interpretationText = explanation.interpretation.medium;
                else interpretationText = explanation.interpretation.low;
            } else if (metricKey === 'totalReturn' || metricKey === 'annualReturn') {
                const threshold1 = metricKey === 'totalReturn' ? 30 : 15;
                const threshold2 = metricKey === 'totalReturn' ? 10 : 7;
                if (value >= threshold1) interpretationText = explanation.interpretation.high;
                else if (value >= threshold2) interpretationText = explanation.interpretation.medium;
                else interpretationText = explanation.interpretation.low;
            }

            // 모달 HTML 생성
            const modalHTML = `
                <div class="metric-explanation-modal" id="metric-explanation-modal" onclick="closeMetricExplanation(event)">
                    <div class="metric-explanation-content" onclick="event.stopPropagation()">
                        <div class="metric-explanation-header">
                            <h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">${explanation.title}</h3>
                            <button class="close-btn text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm w-8 h-8 inline-flex justify-center items-center dark:hover:bg-gray-600 dark:hover:text-white transition-all duration-300" onclick="closeMetricExplanation()">×</button>
                        </div>
                        <div class="metric-explanation-body">
                            <div class="metric-current-value">
                                <span class="label">현재 값:</span>
                                <span class="value">${typeof value === 'number' ? value.toFixed(2) : value}${metricKey.includes('Return') || metricKey.includes('rawdown') ? '%' : ''}</span>
                            </div>
                            <div class="metric-description">
                                <strong>설명:</strong> ${explanation.description}
                            </div>
                            <div class="metric-interpretation">
                                <strong>해석:</strong> ${interpretationText}
                            </div>
                            <div class="metric-formula">
                                <strong>계산식:</strong> <code>${explanation.formula}</code>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // 기존 모달 제거
            const existingModal = document.getElementById('metric-explanation-modal');
            if (existingModal) existingModal.remove();

            // 새 모달 추가
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function closeMetricExplanation(event) {
            const modal = document.getElementById('metric-explanation-modal');
            if (modal) {
                modal.remove();
            }
        }

        // ETF 정보 모달 표시
        function showETFInfo(symbol) {
            const info = etfInfo[symbol];
            if (!info) {
                // ETF 정보가 없는 경우 기본 정보 표시
                const basicInfo = {
                    name: symbol,
                    category: 'ETF',
                    expense: '정보 없음',
                    description: '이 ETF에 대한 상세 정보가 아직 등록되지 않았습니다.'
                };
                displayETFModal(symbol, basicInfo);
                return;
            }
            displayETFModal(symbol, info);
        }

        function displayETFModal(symbol, info) {
            // 모달 HTML 생성
            const modalHTML = `
                <div class="etf-info-modal" id="etf-info-modal" onclick="closeETFInfo(event)">
                    <div class="etf-info-content" onclick="event.stopPropagation()">
                        <div class="etf-info-header">
                            <h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">${symbol}</h3>
                            <button class="close-btn text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm w-8 h-8 inline-flex justify-center items-center dark:hover:bg-gray-600 dark:hover:text-white transition-all duration-300" onclick="closeETFInfo()">×</button>
                        </div>
                        <div class="etf-info-body">
                            <div class="etf-info-row">
                                <span class="label">📊 정식 명칭:</span>
                                <span class="value">${info.name}</span>
                            </div>
                            <div class="etf-info-row">
                                <span class="label">🏷️ 자산 분류:</span>
                                <span class="value">${info.category}</span>
                            </div>
                            <div class="etf-info-row">
                                <span class="label">💰 운용 보수:</span>
                                <span class="value">${info.expense}</span>
                            </div>
                            ${info.description ? `
                                <div class="etf-info-description">
                                    <strong>설명:</strong><br>
                                    ${info.description}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;

            // 기존 모달 제거
            const existingModal = document.getElementById('etf-info-modal');
            if (existingModal) existingModal.remove();

            // 새 모달 추가
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function closeETFInfo(event) {
            const modal = document.getElementById('etf-info-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 튜토리얼 관련 함수
        let currentTutorialStep = 1;
        const totalTutorialSteps = 4;

        function showTutorial() {
            const tutorialOverlay = document.getElementById('tutorial-overlay');
            if (tutorialOverlay) {
                tutorialOverlay.classList.add('active');
                currentTutorialStep = 1;
                updateTutorialStep();
            }
        }

        function closeTutorial() {
            const tutorialOverlay = document.getElementById('tutorial-overlay');
            if (tutorialOverlay) {
                tutorialOverlay.classList.remove('active');
            }
        }

        function nextTutorialStep() {
            if (currentTutorialStep < totalTutorialSteps) {
                currentTutorialStep++;
                updateTutorialStep();
            }
        }

        function prevTutorialStep() {
            if (currentTutorialStep > 1) {
                currentTutorialStep--;
                updateTutorialStep();
            }
        }

        function updateTutorialStep() {
            // 모든 스텝 숨기기
            for (let i = 1; i <= totalTutorialSteps; i++) {
                const step = document.getElementById(`tutorial-step-${i}`);
                if (step) {
                    step.classList.add('hidden');
                }
            }

            // 현재 스텝 표시
            const currentStep = document.getElementById(`tutorial-step-${currentTutorialStep}`);
            if (currentStep) {
                currentStep.classList.remove('hidden');
            }

            // 진행률 도트 업데이트
            document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                if (index + 1 === currentTutorialStep) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });

            // 버튼 상태 업데이트
            const prevBtn = document.querySelector('.tutorial-prev');
            const nextBtn = document.querySelector('.tutorial-next');
            const finishBtn = document.querySelector('.tutorial-finish');

            if (prevBtn) {
                if (currentTutorialStep === 1) {
                    prevBtn.classList.add('hidden');
                } else {
                    prevBtn.classList.remove('hidden');
                }
            }

            if (nextBtn && finishBtn) {
                if (currentTutorialStep === totalTutorialSteps) {
                    nextBtn.classList.add('hidden');
                    finishBtn.classList.remove('hidden');
                } else {
                    nextBtn.classList.remove('hidden');
                    finishBtn.classList.add('hidden');
                }
            }
        }

        function finishTutorial() {
            // "다시 보지 않기" 체크 확인
            const dontShowCheckbox = document.getElementById('tutorial-dont-show');
            if (dontShowCheckbox && dontShowCheckbox.checked) {
                localStorage.setItem('assetflow_tutorial_completed', 'true');
            }
            closeTutorial();
        }

        function checkAndShowTutorial() {
            // 튜토리얼을 이미 본 경우 표시하지 않음
            const tutorialCompleted = localStorage.getItem('assetflow_tutorial_completed');
            if (!tutorialCompleted) {
                // 페이지 로드 후 1초 뒤에 튜토리얼 표시
                setTimeout(() => {
                    showTutorial();
                }, 1000);
            }
        }

        function showLoading(elementId, show = true) {
            const element = document.getElementById(elementId);
            if (element) {
                if (show) {
                    element.classList.remove('hidden');
                    element.style.display = 'flex';
                } else {
                    element.classList.add('hidden');
                    element.style.display = 'none';
                }
            }
        }
        
        function updateProgress(percentage, text = '') {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            if (progressFill) {
                progressFill.style.width = percentage + '%';
            }
            
            if (progressText && text) {
                progressText.textContent = text;
            }
        }
        
        function showProgressBar(show = true) {
            const progressContainer = document.getElementById('backtest-progress');
            if (progressContainer) {
                progressContainer.style.display = show ? 'block' : 'none';
            }
        }
        
        function setButtonLoading(buttonId, loading = true) {
            const button = document.getElementById(buttonId);
            const text = document.getElementById(buttonId.replace('-btn', '-btn-text'));
            const spinner = document.getElementById(buttonId.replace('-btn', '-btn-spinner'));
            
            if (button && text && spinner) {
                if (loading) {
                    button.disabled = true;
                    text.style.display = 'none';
                    spinner.style.display = 'block';
                } else {
                    button.disabled = false;
                    text.style.display = 'block';
                    spinner.style.display = 'none';
                }
            }
        }
        
        // 탭 전환 기능
        function switchTab(tabName) {
            // 모든 탭 버튼 비활성화
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 모든 탭 콘텐츠 숨기기
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 선택된 탭 활성화
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // 탭별 특별 처리
            if (tabName === 'portfolio') {
                setTimeout(() => {
                    createPortfolioCharts();
                    // createAllocationTimelineChart(); // 함수가 정의되지 않음 - 향후 구현 예정
                    // updateRebalancingSimulation(); // 함수가 정의되지 않음 - 향후 구현 예정
                }, 100);
            } else if (tabName === 'detailed') {
                setTimeout(() => generateRealDetailedMetrics(), 100);
            } else if (tabName === 'yearly') {
                setTimeout(() => generateRealYearlyPerformance(), 100);
            } else if (tabName === 'advanced') {
                setTimeout(() => {
                    createDrawdownChart();
                    updateHeatmapStrategySelector();
                    createMonthlyReturnsHeatmap();
                    updateCorrelationStrategySelector();
                    generateRealCorrelationMatrix();
                    updateYearlyStrategySelector();
                    generateAdvancedYearlyPerformance();
                }, 100);
            }
        }
        
        function generateRealDetailedMetrics() {
            const table = document.getElementById('detailed-metrics-table');
            const headerRow = table.querySelector('thead tr');
            const tbody = document.getElementById('detailed-metrics-body');

            if (!table || !headerRow || !tbody) {
                console.error('상세 지표 테이블 요소를 찾을 수 없습니다');
                return;
            }

            // 헤더 생성 (S&P 500 추가)
            let headerHtml = '<th>지표</th><th>S&P 500<br><span style="font-size: 10px; color: var(--text-secondary);">(벤치마크)</span></th>';
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                headerHtml += `<th>${strategy.name}</th>`;
            });
            headerRow.innerHTML = headerHtml;

            // S&P 500 벤치마크 지표 계산
            const spyMetrics = calculateSPYMetrics();
            console.log('SPY 벤치마크 지표:', spyMetrics);
            
            // 지표 데이터 생성
            const metrics = [
                { name: '누적 수익률 (Total Return)', key: 'totalReturn', format: '%', type: 'positive' },
                { name: '연평균 수익률 (CAGR)', key: 'annualReturn', format: '%', type: 'positive' },
                { name: '변동성 (Volatility)', key: 'volatility', format: '%', type: 'neutral' },
                { name: '최대 낙폭 (MDD)', key: 'maxDrawdown', format: '%', type: 'negative' },
                { name: '샤프 비율 (Sharpe Ratio)', key: 'sharpeRatio', format: 'ratio', type: 'positive' },
                { name: '칼마 비율 (Calmar Ratio)', key: 'calmarRatio', format: 'ratio', type: 'positive' },
                { name: '소르티노 비율 (Sortino Ratio)', key: 'sortinoRatio', format: 'ratio', type: 'positive' },
                { name: '승률 (Win Rate)', key: 'winRate', format: '%', type: 'positive' },
                { name: '알파 (Alpha)', key: 'alpha', format: '%', type: 'positive' },
                { name: '베타 (Beta)', key: 'beta', format: 'ratio', type: 'neutral' },
                { name: '상관계수 (Correlation)', key: 'correlation', format: 'ratio', type: 'neutral' },
                { name: '정보 비율 (Information Ratio)', key: 'informationRatio', format: 'ratio', type: 'positive' },
                { name: '회복 기간 (Recovery Period)', key: 'recoveryPeriod', format: 'months', type: 'neutral' },
                { name: '최대 연속 상승 (Max Win Streak)', key: 'maxWinStreak', format: 'count', type: 'positive' },
                { name: '최대 연속 하락 (Max Loss Streak)', key: 'maxLoseStreak', format: 'count', type: 'neutral' },
                { name: '평균 상승폭 (Avg Win Return)', key: 'avgWinReturn', format: '%', type: 'positive' },
                { name: '평균 하락폭 (Avg Loss Return)', key: 'avgLossReturn', format: '%', type: 'negative' },
                { name: '손실위험도 (VaR 95%)', key: 'valueAtRisk95', format: '%', type: 'negative' },
                { name: '꼬리 위험 (Tail Risk)', key: 'tailRisk', format: '%', type: 'negative' }
            ];
            
            let bodyHtml = '';
            metrics.forEach(metric => {
                const hasExplanation = metricExplanations[metric.key];
                const helpIcon = hasExplanation ? 
                    `<span class="help-icon" onclick="showMetricTooltip('${metric.key}', event)">?</span>` : '';
                
                bodyHtml += `<tr><td><div class="metric-help"><strong>${metric.name}</strong>${helpIcon}</div></td>`;
                
                // S&P 500 벤치마크 값
                const spyValue = spyMetrics[metric.key];
                if (spyValue !== undefined && !isNaN(spyValue)) {
                    const formattedValue = formatMetricValue(spyValue, metric.format);
                    let colorClass = 'neutral';
                    
                    // 베타는 1.0이므로 중립, 알파는 0이므로 중립
                    if (metric.key === 'beta' || metric.key === 'alpha') {
                        colorClass = 'neutral';
                    } else {
                        colorClass = getMetricColorClass(spyValue, metric.type);
                    }
                    
                    bodyHtml += `<td class="${colorClass}" style="background: rgba(255, 149, 0, 0.1);"><strong>${formattedValue}</strong></td>`;
                } else {
                    bodyHtml += `<td class="neutral" style="background: rgba(255, 149, 0, 0.1);"><strong>-</strong></td>`;
                }
                
                // 각 전략별 값
                selectedStrategies.forEach(strategyId => {
                    const results = backtestResults[strategyId];
                    if (results && results[metric.key] !== undefined && results[metric.key] !== null) {
                        const value = results[metric.key];
                        const formattedValue = formatMetricValue(value, metric.format);
                        const colorClass = getMetricColorClass(value, metric.type);
                        bodyHtml += `<td class="${colorClass}">${formattedValue}</td>`;
                    } else {
                        // 디버깅: 값이 없는 경우 로그 출력
                        if (metric.key === 'annualReturn' || metric.key === 'totalReturn') {
                            console.warn(`${strategyId}의 ${metric.key} 값이 없습니다:`, results ? results[metric.key] : 'results 없음');
                        }
                        bodyHtml += `<td class="neutral">-</td>`;
                    }
                });
                bodyHtml += '</tr>';
            });

            console.log('백테스트 결과:', backtestResults);
            tbody.innerHTML = bodyHtml;
        }
        
        function calculateYearlyReturns(strategyId) {
            const performanceData = portfolioTimeSeries[strategyId];
            
            // performanceData가 객체인지 배열인지 확인
            const values = performanceData.values || performanceData;
            
            if (!values || values.length === 0) {
                console.error(`${strategyId}의 시계열 데이터가 없습니다`);
                return {};
            }
            
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const dates = generateDateRange(startDate, endDate);
            
            const yearlyReturns = {};
            
            // 각 연도별로 수익률 계산
            const startYear = new Date(startDate).getFullYear();
            const endYear = new Date(endDate).getFullYear();
            
            for (let year = startYear; year <= endYear; year++) {
                // 해당 연도의 시작과 끝 인덱스 찾기
                const yearStartIndex = dates.findIndex(date => date.getFullYear() === year);
                const yearEndIndex = dates.findIndex(date => date.getFullYear() === year + 1);
                
                if (yearStartIndex >= 0 && yearStartIndex < values.length) {
                    let endIndex;
                    if (yearEndIndex > 0 && yearEndIndex < values.length) {
                        endIndex = yearEndIndex - 1; // 해당 연도의 마지막 달
                    } else {
                        // 마지막 연도이거나 다음 연도를 찾지 못한 경우
                        endIndex = dates.findIndex((date, idx) => 
                            idx > yearStartIndex && date.getFullYear() > year
                        );
                        if (endIndex === -1) {
                            endIndex = values.length - 1;
                        } else {
                            endIndex = endIndex - 1;
                        }
                    }
                    
                    if (endIndex >= yearStartIndex && endIndex < values.length) {
                        const yearStartValue = values[yearStartIndex];
                        const yearEndValue = values[endIndex];
                        
                        if (yearStartValue && yearStartValue > 0) {
                            yearlyReturns[year] = ((yearEndValue - yearStartValue) / yearStartValue) * 100;
                        }
                    }
                }
            }
            
            // 누적 수익률
            if (values.length > 0 && values[0] > 0) {
                yearlyReturns.cumulative = ((values[values.length - 1] - values[0]) / values[0]) * 100;
            }
            
            return yearlyReturns;
        }

        function calculateSPYYearlyReturns() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            if (!localETFData['SPY'] || localETFData['SPY'].length === 0) {
                console.warn('SPY 데이터가 없습니다');
                return {};
            }
            
            const spyData = localETFData['SPY'];
            const yearlyReturns = {};
            
            const startYear = new Date(startDate).getFullYear();
            const endYear = new Date(endDate).getFullYear();
            
            for (let year = startYear; year <= endYear; year++) {
                // 해당 연도의 첫 거래일과 마지막 거래일 찾기
                const yearStart = spyData.find(d => {
                    const date = new Date(d.date);
                    return date.getFullYear() === year;
                });
                
                const yearEnd = spyData.filter(d => {
                    const date = new Date(d.date);
                    return date.getFullYear() === year;
                }).pop();
                
                if (yearStart && yearEnd && yearStart.price && yearEnd.price && yearStart.price > 0) {
                    yearlyReturns[year] = ((yearEnd.price - yearStart.price) / yearStart.price) * 100;
                }
            }
            
            // 누적 수익률
            const firstData = spyData.find(d => new Date(d.date) >= new Date(startDate));
            const lastData = spyData.filter(d => new Date(d.date) <= new Date(endDate)).pop();
            
            if (firstData && lastData && firstData.price && lastData.price && firstData.price > 0) {
                yearlyReturns.cumulative = ((lastData.price - firstData.price) / firstData.price) * 100;
            }
            
            return yearlyReturns;
        }

        function calculateSPYMetrics() {
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;

            console.log('🔍 SPY 지표 계산 시작:', { startDate, endDate });
            console.log('📊 localETFData에 SPY 존재?', !!localETFData['SPY']);
            console.log('📊 SPY 데이터 길이:', localETFData['SPY'] ? localETFData['SPY'].length : 0);

            if (!localETFData['SPY'] || localETFData['SPY'].length === 0) {
                console.error('❌ SPY 데이터가 없습니다!');
                return {
                    totalReturn: 0,
                    annualReturn: 0,
                    volatility: 0,
                    maxDrawdown: 0,
                    sharpeRatio: 0,
                    calmarRatio: 0,
                    sortinoRatio: 0,
                    winRate: 0,
                    beta: 1.0,
                    alpha: 0,
                    correlation: 1.0
                };
            }

            try {
                // SPY를 100% 배분한 가상 전략 생성
                const spyStrategy = {
                    name: 'S&P 500',
                    allocation: { 'SPY': 100 },
                    etfs: { 'SPY': 100 },
                    rebalancing: 'none'
                };

                console.log('📈 SPY 백테스트 전략:', spyStrategy);

                // SPY 성과 계산
                const spyPerformanceData = calculatePortfolioPerformance(
                    spyStrategy,
                    startDate,
                    endDate,
                    localETFData
                );

                console.log('📊 SPY 백테스트 결과:', spyPerformanceData);

                // 객체인 경우 values 추출
                const spyValues = spyPerformanceData.values || spyPerformanceData;

                console.log('📊 SPY values 길이:', spyValues ? spyValues.length : 0);
                console.log('📊 SPY 초기/최종 값:', {
                    initial: spyValues[0],
                    final: spyValues[spyValues.length - 1]
                });

                if (!spyValues || spyValues.length === 0) {
                    throw new Error('SPY 성과 데이터가 비어있습니다');
                }

                // 지표 계산 - 벤치마크 계산 건너뛰기 (SPY 자체를 계산 중이므로)
                // 🔧 수정: spyValues가 아닌 전체 spyPerformanceData 객체 전달
                const spyMetrics = calculateMetrics(spyPerformanceData, spyStrategy, startDate, endDate, true);

                console.log('✅ SPY 지표 계산 완료:', spyMetrics);

                // SPY는 자기 자신이 벤치마크이므로
                spyMetrics.beta = 1.0;
                spyMetrics.alpha = 0;
                spyMetrics.correlation = 1.0;
                spyMetrics.informationRatio = 0;

                return spyMetrics;
                
            } catch (error) {
                console.error('SPY 지표 계산 오류:', error);
                return {
                    totalReturn: 0,
                    annualReturn: 0,
                    volatility: 0,
                    maxDrawdown: 0,
                    sharpeRatio: 0,
                    calmarRatio: 0,
                    sortinoRatio: 0,
                    winRate: 0,
                    beta: 1.0,
                    alpha: 0,
                    correlation: 1.0
                };
            }
        }

        // 고급 분석 탭의 연도별 성과 생성 (선택된 전략만)
        function generateAdvancedYearlyPerformance() {
            const table = document.getElementById('yearly-table-advanced');
            const headerRow = document.getElementById('yearly-table-advanced-header');
            const tbody = document.getElementById('yearly-table-advanced-body');

            if (!table || !headerRow || !tbody) return;

            // 선택된 전략이 없으면 빈 메시지 표시
            if (yearlySelectedStrategies.length === 0) {
                headerRow.innerHTML = '<th>전략</th>';
                tbody.innerHTML = '<tr><td style="text-align: center; padding: 20px; color: var(--text-secondary);">전략을 선택해주세요.</td></tr>';
                return;
            }

            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const startYear = new Date(startDate).getFullYear();
            const endYear = new Date(endDate).getFullYear();

            // 동적 헤더 생성
            let headerHtml = '<th>전략</th>';
            for (let year = startYear; year <= endYear; year++) {
                headerHtml += `<th>${year}</th>`;
            }
            headerHtml += '<th>누적</th>';
            headerRow.innerHTML = headerHtml;

            let bodyHtml = '';

            // 선택된 전략별 연도별 성과
            yearlySelectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const yearlyReturns = calculateYearlyReturns(strategyId);

                bodyHtml += `<tr><td class="strategy-name">${strategy.name}</td>`;

                for (let year = startYear; year <= endYear; year++) {
                    const returnValue = yearlyReturns[year];
                    if (returnValue !== undefined && !isNaN(returnValue)) {
                        const colorClass = returnValue >= 0 ? 'positive' : 'negative';
                        bodyHtml += `<td class="${colorClass}">${returnValue >= 0 ? '+' : ''}${returnValue.toFixed(1)}%</td>`;
                    } else {
                        bodyHtml += `<td class="neutral">-</td>`;
                    }
                }

                // 누적 수익률
                const cumulative = yearlyReturns.cumulative;
                if (cumulative !== undefined && !isNaN(cumulative)) {
                    const colorClass = cumulative >= 0 ? 'positive' : 'negative';
                    bodyHtml += `<td class="${colorClass}"><strong>${cumulative >= 0 ? '+' : ''}${cumulative.toFixed(1)}%</strong></td>`;
                } else {
                    bodyHtml += `<td class="neutral"><strong>-</strong></td>`;
                }

                bodyHtml += '</tr>';
            });

            tbody.innerHTML = bodyHtml;
        }

        function generateRealYearlyPerformance() {
            const table = document.getElementById('yearly-table');
            const headerRow = table.querySelector('thead tr');
            const tbody = document.getElementById('yearly-table-body');
            
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            const startYear = new Date(startDate).getFullYear();
            const endYear = new Date(endDate).getFullYear();
            
            // 동적 헤더 생성
            let headerHtml = '<th>전략</th>';
            for (let year = startYear; year <= endYear; year++) {
                headerHtml += `<th>${year}</th>`;
            }
            headerHtml += '<th>누적</th>';
            headerRow.innerHTML = headerHtml;

            let bodyHtml = '';

            // S&P 500 벤치마크를 먼저 추가
            const spyYearlyReturns = calculateSPYYearlyReturns();
            bodyHtml += `<tr style="border-bottom: 2px solid var(--border-subtle); background: var(--bg-warning-alpha);">
                <td class="strategy-name"><strong>S&P 500</strong> <span style="font-size: 11px; color: var(--text-secondary);">(벤치마크)</span></td>`;
            
            for (let year = startYear; year <= endYear; year++) {
                const returnValue = spyYearlyReturns[year];
                if (returnValue !== undefined && !isNaN(returnValue)) {
                    const colorClass = returnValue >= 0 ? 'positive' : 'negative';
                    bodyHtml += `<td class="${colorClass}">${returnValue >= 0 ? '+' : ''}${returnValue.toFixed(1)}%</td>`;
                } else {
                    bodyHtml += `<td class="neutral">-</td>`;
                }
            }
            
            // 누적 수익률
            const spyCumulative = spyYearlyReturns.cumulative;
            if (spyCumulative !== undefined && !isNaN(spyCumulative)) {
                const colorClass = spyCumulative >= 0 ? 'positive' : 'negative';
                bodyHtml += `<td class="${colorClass}"><strong>${spyCumulative >= 0 ? '+' : ''}${spyCumulative.toFixed(1)}%</strong></td>`;
            } else {
                bodyHtml += `<td class="neutral"><strong>-</strong></td>`;
            }

            bodyHtml += '</tr>';

            // 각 전략별 연도별 성과 (벤치마크 다음에 표시)
            selectedStrategies.forEach(strategyId => {
                const strategy = strategies[strategyId];
                const yearlyReturns = calculateYearlyReturns(strategyId);

                bodyHtml += `<tr><td class="strategy-name">${strategy.name}</td>`;

                for (let year = startYear; year <= endYear; year++) {
                    const returnValue = yearlyReturns[year];
                    if (returnValue !== undefined && !isNaN(returnValue)) {
                        const colorClass = returnValue >= 0 ? 'positive' : 'negative';
                        bodyHtml += `<td class="${colorClass}">${returnValue >= 0 ? '+' : ''}${returnValue.toFixed(1)}%</td>`;
                    } else {
                        bodyHtml += `<td class="neutral">-</td>`;
                    }
                }

                // 누적 수익률
                const cumulative = yearlyReturns.cumulative;
                if (cumulative !== undefined && !isNaN(cumulative)) {
                    const colorClass = cumulative >= 0 ? 'positive' : 'negative';
                    bodyHtml += `<td class="${colorClass}"><strong>${cumulative >= 0 ? '+' : ''}${cumulative.toFixed(1)}%</strong></td>`;
                } else {
                    bodyHtml += `<td class="neutral"><strong>-</strong></td>`;
                }

                bodyHtml += '</tr>';
            });

            tbody.innerHTML = bodyHtml;
        }

        // ========== 벤치마크 비교 기능 제거됨 (사용자 요청) ==========
        // function generateRealBenchmarkComparison() {
        //     const table = document.getElementById('benchmark-table');
        //     const headerRow = table.querySelector('thead tr');
        //     const tbody = document.getElementById('benchmark-table-body');
        //
        //     // 헤더 생성
        //     let headerHtml = '<th>지표</th><th>S&P 500</th>';
        //     selectedStrategies.forEach(strategyId => {
        //         const strategy = strategies[strategyId];
        //         headerHtml += `<th>${strategy.name}</th>`;
        //     });
        //     headerRow.innerHTML = headerHtml;
        //
        //     // SPY 벤치마크 성과 계산
        //     const spyMetrics = calculateSPYMetrics();
        //
        //     // 벤치마크 비교 지표
        //     const compareMetrics = [
        //         { name: '누적 수익률 (Total Return)', key: 'totalReturn', format: '%' },
        //         { name: '변동성 (Volatility)', key: 'volatility', format: '%' },
        //         { name: '샤프 비율 (Sharpe Ratio)', key: 'sharpeRatio', format: 'ratio' },
        //         { name: '최대 낙폭 (MDD)', key: 'maxDrawdown', format: '%' },
        //         { name: '베타 (Beta)', key: 'beta', format: 'ratio' },
        //         { name: '알파 (Alpha)', key: 'alpha', format: '%' },
        //         { name: '상관계수 (Correlation)', key: 'correlation', format: 'ratio' }
        //     ];
        //
        //     let bodyHtml = '';
        //     compareMetrics.forEach(metric => {
        //         bodyHtml += `<tr><td><strong>${metric.name}</strong></td>`;
        //
        //         // 벤치마크 값
        //         const benchmarkValue = spyMetrics[metric.key] || 0;
        //         bodyHtml += `<td class="neutral">${formatMetricValue(benchmarkValue, metric.format)}</td>`;
        //
        //         selectedStrategies.forEach(strategyId => {
        //             const strategyMetrics = backtestResults[strategyId];
        //
        //             if (strategyMetrics && strategyMetrics[metric.key] !== undefined) {
        //                 const value = strategyMetrics[metric.key];
        //                 const formattedValue = formatMetricValue(value, metric.format);
        //
        //                 // 벤치마크 대비 성과 표시
        //                 let colorClass = 'neutral';
        //                 if (metric.key === 'totalReturn' || metric.key === 'sharpeRatio' || metric.key === 'alpha') {
        //                     colorClass = value > benchmarkValue ? 'positive' : 'negative';
        //                 } else if (metric.key === 'volatility' || metric.key === 'maxDrawdown') {
        //                     colorClass = value < benchmarkValue ? 'positive' : 'negative';
        //                 }
        //
        //                 bodyHtml += `<td class="${colorClass}">${formattedValue}</td>`;
        //             } else {
        //                 bodyHtml += `<td class="neutral">N/A</td>`;
        //             }
        //         });
        //         bodyHtml += '</tr>';
        //     });
        //
        //     tbody.innerHTML = bodyHtml;
        // }
        // ========== 벤치마크 비교 기능 제거 끝 ==========
        

        // S&P 500 (SPY) 성과 계산
        function calculateSPYPerformance(startDate, endDate, etfData) {
            if (!etfData['SPY'] || etfData['SPY'].length === 0) {
                console.error('SPY 데이터가 없습니다. 엑셀 파일에서 SPY ETF 가격 데이터를 업로드해주세요.');
                showNotification('SPY 데이터가 없습니다. 벤치마크 비교를 위해 SPY ETF 데이터를 업로드해주세요.', 'warning', 3000);
                return [];
            }

            const dates = generateDateRange(startDate, endDate);
            const performance = [];

            const initialPrice = getETFPrice('SPY', dates[0], etfData);
            if (!initialPrice) {
                console.error('SPY 초기 가격을 찾을 수 없습니다. 선택한 시작일(' + startDate + ')에 해당하는 SPY 데이터가 없습니다.');
                showNotification('선택한 기간의 SPY 데이터가 없습니다.', 'warning', 3000);
                return [];
            }

            // 초기값은 0%로 시작
            performance.push(0);

            for (let i = 1; i < dates.length; i++) {
                const price = getETFPrice('SPY', dates[i], etfData);
                if (price) {
                    const returnPct = ((price - initialPrice) / initialPrice) * 100;
                    performance.push(returnPct);
                } else {
                    // 가격 데이터가 없으면 이전 값 유지
                    performance.push(performance[performance.length - 1] || 0);
                }
            }

            return performance;
        }

        // ========== 벤치마크 차트 생성 기능 제거됨 (사용자 요청) ==========
        // function createBenchmarkChart() {
        //     const ctx = document.getElementById('benchmark-chart').getContext('2d');
        //
        //     if (benchmarkChart) {
        //         benchmarkChart.destroy();
        //     }
        //
        //     const startDate = document.getElementById('start-date').value;
        //     const endDate = document.getElementById('end-date').value;
        //
        //     const dates = generateDateRange(startDate, endDate);
        //     const labels = dates.map(d => {
        //         const month = d.getMonth() + 1;
        //         const year = d.getFullYear();
        //         return `${year}-${month.toString().padStart(2, '0')}`;
        //     });
        //
        //     const datasets = [];
        //
        //     const spyData = calculateSPYPerformance(startDate, endDate, localETFData);
        //     datasets.push({
        //         label: 'S&P 500',
        //         data: spyData,
        //         borderColor: '#FF9500',
        //         backgroundColor: '#FF950020',
        //         borderWidth: 3,
        //         borderDash: [5, 5],
        //         fill: false,
        //         tension: 0.4,
        //         pointRadius: 0,
        //         pointHoverRadius: 6
        //     });
        //
        //     selectedStrategies.forEach(strategyId => {
        //         const strategy = strategies[strategyId];
        //         const performanceData = calculatePortfolioPerformance(strategy, startDate, endDate, localETFData);
        //
        //         if (performanceData.length === 0) {
        //             console.warn(`${strategy.name} 데이터가 없습니다`);
        //             return;
        //         }
        //
        //         const percentageData = performanceData.map(v => ((v - 100) / 100) * 100);
        //
        //         datasets.push({
        //             label: strategy.name,
        //             data: percentageData,
        //             borderColor: strategy.color,
        //             backgroundColor: strategy.color + '20',
        //             borderWidth: 2,
        //             fill: false,
        //             tension: 0.4,
        //             pointRadius: 0,
        //             pointHoverRadius: 6
        //         });
        //     });
        //
        //     benchmarkChart = new Chart(ctx, {
        //         type: 'line',
        //         data: { labels, datasets },
        //         options: {
        //             responsive: true,
        //             maintainAspectRatio: false,
        //             plugins: {
        //                 legend: {
        //                     display: true,
        //                     labels: {
        //                         color: isDarkMode ? '#ffffff' : '#000000',
        //                         font: { size: 12 }
        //                     }
        //                 },
        //                 tooltip: {
        //                     mode: 'index',
        //                     intersect: false
        //                 }
        //             },
        //             scales: {
        //                 x: {
        //                     ticks: {
        //                         color: isDarkMode ? '#8E8E93' : '#666',
        //                         maxRotation: 45,
        //                         minRotation: 45
        //                     },
        //                     grid: { color: isDarkMode ? '#333' : '#ddd' }
        //                 },
        //                 y: {
        //                     ticks: {
        //                         color: isDarkMode ? '#8E8E93' : '#666',
        //                         callback: value => value.toFixed(2) + '%'
        //                     },
        //                     grid: { color: isDarkMode ? '#333' : '#ddd' }
        //                 }
        //             }
        //         }
        //     });
        // }
        // ========== 벤치마크 차트 생성 기능 제거 끝 ==========

        function calculateRealCorrelations(strategiesToUse) {
            const correlations = {};
            const strategiesArray = strategiesToUse || selectedStrategies;

            strategiesArray.forEach((strategyId1, i) => {
                strategiesArray.forEach((strategyId2, j) => {
                    if (i === j) {
                        correlations[`${i}-${j}`] = 1.0;
                    } else {
                        const data1 = portfolioTimeSeries[strategyId1];
                        const data2 = portfolioTimeSeries[strategyId2];

                        // portfolioTimeSeries는 {values: [], allocations: [], rebalanceCount: n} 형태
                        const timeSeries1 = data1?.values || data1;
                        const timeSeries2 = data2?.values || data2;

                        if (timeSeries1 && timeSeries2 && Array.isArray(timeSeries1) && Array.isArray(timeSeries2)) {
                            const returns1 = calculateReturns(timeSeries1);
                            const returns2 = calculateReturns(timeSeries2);
                            correlations[`${i}-${j}`] = calculateCorrelation(returns1, returns2);
                        } else {
                            console.warn(`상관관계 계산 실패: ${strategyId1} 또는 ${strategyId2}의 시계열 데이터가 없습니다.`);
                            correlations[`${i}-${j}`] = 0;
                        }
                    }
                });
            });

            return correlations;
        }

        function calculateReturns(timeSeries) {
            const returns = [];
            for (let i = 1; i < timeSeries.length; i++) {
                if (timeSeries[i-1] !== 0) {
                    returns.push((timeSeries[i] - timeSeries[i-1]) / timeSeries[i-1]);
                }
            }
            return returns;
        }

        function calculateCorrelation(returns1, returns2) {
            if (returns1.length !== returns2.length || returns1.length === 0) {
                return 0;
            }
            
            const mean1 = returns1.reduce((a, b) => a + b, 0) / returns1.length;
            const mean2 = returns2.reduce((a, b) => a + b, 0) / returns2.length;
            
            let numerator = 0;
            let sum1 = 0;
            let sum2 = 0;
            
            for (let i = 0; i < returns1.length; i++) {
                const diff1 = returns1[i] - mean1;
                const diff2 = returns2[i] - mean2;
                numerator += diff1 * diff2;
                sum1 += diff1 * diff1;
                sum2 += diff2 * diff2;
            }
            
            const denominator = Math.sqrt(sum1 * sum2);
            return denominator === 0 ? 0 : numerator / denominator;
        }

        function generateRealCorrelationMatrix() {
            const container = document.getElementById('correlation-matrix');
            if (!container) return;

            // 선택된 전략이 없으면 빈 컨테이너
            if (correlationSelectedStrategies.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">전략을 선택해주세요.</p>';
                return;
            }

            // 최소 2개 이상의 전략이 필요
            if (correlationSelectedStrategies.length < 2) {
                container.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">상관관계 계산을 위해 최소 2개의 전략을 선택해주세요.</p>';
                return;
            }

            const strategyNames = correlationSelectedStrategies.map(id => strategies[id].name);
            const n = strategyNames.length;

            // 그리드 설정 (n+1 x n+1)
            container.style.gridTemplateColumns = `repeat(${n + 1}, 1fr)`;

            let html = '<div class="correlation-cell correlation-header"></div>';

            // 헤더 행
            strategyNames.forEach(name => {
                html += `<div class="correlation-cell correlation-header">${name.slice(0, 8)}</div>`;
            });

            // 실제 상관관계 계산 (선택된 전략들만)
            const correlations = calculateRealCorrelations(correlationSelectedStrategies);

            // 데이터 행들
            strategyNames.forEach((rowName, i) => {
                html += `<div class="correlation-cell correlation-header">${rowName.slice(0, 8)}</div>`;
                strategyNames.forEach((colName, j) => {
                    const correlation = correlations[`${i}-${j}`] || 0;
                    const color = getCorrelationColor(correlation);
                    html += `<div class="correlation-cell" style="background-color: ${color}; color: white;">${correlation.toFixed(2)}</div>`;
                });
            });

            container.innerHTML = html;
        }
        
        // 이 함수들은 이미 위에서 구현되었으므로 중복 제거
        
        function changePeriod(period) {
            currentPeriod = period;
            
            document.querySelectorAll('.period-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.querySelector(`[data-period="${period}"]`).classList.add('active');
            
            if (comparisonChart) {
                createComparisonChart();
                showNotification(`${period === 'all' ? '전체' : period + '년'} 기간으로 변경되었습니다.`, 'success', 1500);
            }
        }
        
        function resetChartZoom() {
            if (comparisonChart) {
                createComparisonChart();
                showNotification('차트가 초기화되었습니다.', 'info', 1500);
            }
        }
        
        function downloadChart() {
            if (comparisonChart) {
                const canvas = comparisonChart.canvas;
                const link = document.createElement('a');
                link.download = `AssetFlow_차트_${new Date().toISOString().split('T')[0]}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                showNotification('차트 이미지가 다운로드되었습니다.', 'success');
            }
        }
        
        function exportDetailedReport() {
            const report = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    backtestPeriod: {
                        start: document.getElementById('start-date').value,
                        end: document.getElementById('end-date').value
                    },
                    strategies: selectedStrategies.map(id => strategies[id].name)
                },
                results: backtestResults,
                timeSeries: portfolioTimeSeries,
                settings: {
                    rebalancing: document.getElementById('user-rebalancing-override').value,
                    assumptions: BACKTEST_ASSUMPTIONS
                }
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `AssetFlow_Report_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            showNotification('상세 리포트가 다운로드되었습니다', 'success');
        }

        function showDataPointDetail(datasetIndex, dataIndex, event) {
            const dataset = comparisonChart.data.datasets[datasetIndex];
            const label = comparisonChart.data.labels[dataIndex];

            if (!dataset || !label) return;

            const value = dataset.data[dataIndex];
            const strategyId = selectedStrategies[datasetIndex];
            const strategy = strategies[strategyId];
            const change = calculateChange(datasetIndex, dataIndex);

            const overlay = document.getElementById('chart-info-overlay');
            overlay.innerHTML = `
                <div class="chart-info-title">${strategy.name}</div>
                <div class="chart-info-item">
                    <span class="chart-info-label">기간:</span>
                    <span class="chart-info-value">${label}</span>
                </div>
                <div class="chart-info-item">
                    <span class="chart-info-label">누적 수익률:</span>
                    <span class="chart-info-value ${value >= 100 ? 'positive' : 'negative'}">${Math.round(value)}%</span>
                </div>
                <div class="chart-info-item">
                    <span class="chart-info-label">기간 변화:</span>
                    <span class="chart-info-value ${change.includes('+') ? 'positive' : 'negative'}">${change}</span>
                </div>
            `;
            
            overlay.classList.add('show');
            
            setTimeout(() => {
                hideChartInfoOverlay();
            }, 5000);
        }
        
        function calculateChange(datasetIndex, dataIndex) {
            try {
                if (dataIndex === 0 || !comparisonChart || !comparisonChart.data || !comparisonChart.data.datasets) {
                    return 'N/A';
                }
                
                const dataset = comparisonChart.data.datasets[datasetIndex];
                if (!dataset || !dataset.data) {
                    return 'N/A';
                }
                
                const currentValue = dataset.data[dataIndex];
                const previousValue = dataset.data[dataIndex - 1];
                
                if (typeof currentValue !== 'number' || typeof previousValue !== 'number' || previousValue === 0) {
                    return 'N/A';
                }
                
                const change = ((currentValue - previousValue) / previousValue * 100);
                return `${change >= 0 ? '+' : ''}${Math.round(change)}%`;
            } catch (error) {
                console.error('Error calculating change:', error);
                return 'N/A';
            }
        }
        
        function hideChartInfoOverlay() {
            const overlay = document.getElementById('chart-info-overlay');
            overlay.classList.remove('show');
        }
        
        // 툴팁 표시 함수
        function showMetricTooltip(metricKey, event) {
            const tooltip = document.getElementById('metric-tooltip');
            const explanation = metricExplanations[metricKey];
            
            if (!explanation) return;
            
            // 툴팁 내용 설정
            document.getElementById('tooltip-title').textContent = explanation.title;
            document.getElementById('tooltip-description').textContent = explanation.description;
            document.getElementById('tooltip-formula').textContent = explanation.formula;

            // interpretation 객체를 문자열로 변환 (모든 키 동적으로 읽기)
            let interpretationText = '';
            if (explanation.interpretation) {
                const interpretationLines = Object.values(explanation.interpretation)
                    .filter(val => val) // undefined 제거
                    .map(val => `• ${val}`);
                interpretationText = interpretationLines.length > 0
                    ? `📊 해석 기준:\n${interpretationLines.join('\n')}`
                    : '';
            }
            document.getElementById('tooltip-interpretation').textContent = interpretationText;
            
            // 위치 계산
            const rect = event.target.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
            let top = rect.top - tooltipRect.height - 10;
            
            // 화면 경계 체크
            const margin = 10;
            left = Math.max(margin, Math.min(left, window.innerWidth - tooltipRect.width - margin));
            if (top < margin) {
                top = rect.bottom + 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.add('show');
        }
        
        function hideMetricTooltip() {
            const tooltip = document.getElementById('metric-tooltip');
            tooltip.classList.remove('show');
        }
        
        // 문서 클릭 시 툴팁 숨기기
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.help-icon') && !event.target.closest('.metric-tooltip')) {
                hideMetricTooltip();
            }





        });


    </script>


    <!-- Flowbite JS -->
    <script src="https://cdn.jsdelivr.net/npm/flowbite@2.5.1/dist/flowbite.min.js"></script>

</body>
</html>
